{
  "hash": "12d7db181004b7ebfc3b0c1d2711a073",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Why do we sleep on factors?\"\nsubtitle: \"And how I wish things may behave?\"\ndate: \"2024-02-15\"\ncategories: [r]\n---\n\n\nFactors are R's version of an enum(eration) ([related post](../posts/2023-11-10-enums-in-r/index.qmd)). They're quite handy and I think we can probably rely on them a bit more for enumations like `c(\"a\", \"b\", \"c\")`. Today I've been helping test a new possible feature of [`extendr`](https://extendr.github.io/) involving factors and it has me thinking a bit about some behaviors. Here are my extemporaneous thoughts: \n\n\nWhen we have a factor, how can we get new values and associate it with an existing factor? \n\nFor example, we can create a factor of the alphabet. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- as.factor(letters)\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n:::\n\n\nSay we have new values that match the level names and want to extend the vector or create a new one based on the levels. \n\nIt would be _nice_ if we could subset a factor based on the levels name\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] <NA>\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n:::\n\n\nbut this gives us an `NA` because there is no named element `\"a\"`. If we gave them names we could access it accordingly\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetNames(f, letters)[\"a\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na \na \nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n:::\n\n\nbut this would be antithetical to the efficiency of a factor. \n\n:::{.aside}\nThey key selling point of a factor is that we define the levels only once and associate them based on integer positions. This is far far far faster and more memory efficient than repeating a value a sh!t ton of times. \n:::\n\nTo create a new factor we have to pass in the levels accordingly: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactor(\"d\", levels(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] d\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n:::\n\n\nThis is actually pretty nice! But I feel like there could be an even better experience, though I don't know what it would be...\n\nIf we wanted to extend the vector by combining the existing factor with levels names we coerce to a character vector but instead of the levels we get the integer values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(f, \"a\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n[16] \"16\" \"17\" \"18\" \"19\" \"20\" \"21\" \"22\" \"23\" \"24\" \"25\" \"26\" \"a\" \n```\n\n\n:::\n:::\n\n\nTo combine them we would need to ensure that they are both factors. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(f, factor(\"d\", levels(f)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] a b c d e f g h i j k l m n o p q r s t u v w x y z d\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n:::\n\n\n## Using `vctrs`\n\nUpon further thinking, [`vctrs`](https://vctrs.r-lib.org/) tends to have the type-safe behavior that I wish from R (and aspects of it should probably be adapted into base R). \n\nI think vctrs gets to the behavior that I want actually. If I have a value and I use `vctrs::vec_cast()` and provide the existing factor vector `f` to the `to` argument, it will use the levels. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::vec_cast(\"z\", f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] z\nLevels: a b c d e f g h i j k l m n o p q r s t u v w x y z\n```\n\n\n:::\n:::\n\n\nBut this _will not_ succeed if we pass it a value that is unknown. The error message is a bit cryptic and frankly feels a little pythonic in the verbosity of the traceback! But this is type safe! And I LIKE IT! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvctrs::vec_cast(\"123\", f)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! Can't convert from `\"123\"` <character> to <factor<754f0>> due to loss of generality.\nâ€¢ Locations: 1\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}