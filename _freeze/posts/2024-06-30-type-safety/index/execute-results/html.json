{
  "hash": "f92bc7144e48572aa33b958dfb10206f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Type safe(r) R code\"\nsubtitle: \"Robust type checking with r-lib\"\ndate: \"2024-07-01\"\ncategories: [r]\n---\n\n\n\n## Introduction to r-lib type safety checks\n\nType safety is all the rage these days. Itâ€™s the (one of the many) reason why people love Rust , TypeScript, and Pydantic.\n\nKnowing what type of data is coming in and going out of a function is critical! It means fewer bugs and more robust code.  \n\nI will introduce you to the r-lib standalone checks. Here is a peek of some code from`{arcgisgeocode}` that helps make the function more type safe.  \n\n![](images/Untitled.png){width=\"50%\"}\n\n## What is type safety?\n\nA type safe language is one where each variable has a known  and *validated* type. R ***is not type safe.*** \n\nWhen you define a function in a type safe language, you have to specify the input types and the output types. \n\nHere is a function that scales one numeric variable by another.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscale_by <- function(x, y) {\n  x / y\n}\n```\n:::\n\n\n**This is not type safe**. I can pass in a **character** vector a **list**, **NULL**, or even a **POSIXct** class. Sometimes R will do the appropriate conversions for us. But other times it wont. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nscale_by(100, \"10\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x/y: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n**You want to be in control of your function!** \n\n## Why type safety is important\n\nType safety allows us to catch and prevent errors early and thus **prevent unintended bugs**. Without type safety, R may perform silent **coercions** or your code may run as R intendedâ€”but not *as you* intended. \n\n<aside>\nðŸ’¡ A type **coercion** is a type conversion that occurs because one type does not match the other and is done silently. **Casting** is when you explicitly change the typeâ€”e.g. calling `as.integer()` on `doubles()`\n\n</aside>\n\nAdding type guarantees ensures that your code functions as intended. \n\n## Type safety in other languages\n\nType safety is becoming an increasingly common and more important aspect of programming. People love Rust for its type safety among other things. Rust (and C/++ and Java and Scala etc) is a **statically typed** language.\n\n<aside>\nðŸ’¡ A statically typed language requires you to specify the *type* of object that are used in a function and elsewhere.\n\n</aside>\n\n### Rustâ€™s static typing\n\nIn Rust, you define a type and that type is unique. \n\n```rust\nstruct Person {\n\tname: String,\n\tage: u8\n}\n```\n\nTo create a person you would write `Person { name: \"Josiah\".to_string(), age: 28 }` . This is recognized as a `Person` struct. In Rust, a function must know its argument types, for example: \n\n```rust\nfn calculate_birth_year(person: &Person) -> i32 {\n\t// use chrono::DateLike\n\tlet now = chrono::Utc::now();\n\t(now.year() - person.age as i32) \n}\n```\n\nThis function takes a reference to a `Person` and calculates (roughly) what year they were born in. If I had another struct called `Me` with the same exact fields, this wouldnâ€™t work. \n\n```rust\nstruct Me {\n\tname: String,\n\tage: u8\n}\n```\n\nEven though `Me` and `Person` have the exact same field types, they are recognized as different types. \n\nThis is different than how JavaScript does this.\n\n### TypeScript Interfaces\n\nThe JavaScript folks now have TypeScript which is pseudo-type safety. TypeScript uses **duck typing.**\n\n<aside>\nðŸ’¡ If it looks like a duck, swims like a duck, and quacks like a duck, this it probably *is* a duck.\n\n</aside>\n\nIf I understand TypeScript correctly, they use a type **interface.** These feel similar to struct definitions in Rust. \n\n```tsx\ninterface Person {\n\tname: string;\n\tage: number;\n}\n```\n\nIn TypeScript, these interfaces are a way to standardizes what a type *looks like*. But not an actual type themself! This is (I think), the equivalent JavaScript code to calculate the birth year of an individual.\n\n```tsx\nfunction calculateBirthYear(person: Person) {\n\t\tDate().getFullYear() - person.age\n}\n```\n\nWith this, though, you donâ€™t actually need to have an instance of `Person` . Instead, you can have a normal JavaScript object that *looks* (and quacks) just like the `Person` type. \n\n```tsx\nconst john: Person = {\n    name: 'John Doe',\n    age: 30\n}\n\nlet jane = { name: 'Jane Doe', age: 28 }\n\nconsole.log(calculateBirthYear(john));\nconsole.log(calculateBirthYear(jane));\n```\n\nThese both work. \n\n## Type safety in R\n\nLike JavaScript, and Python (yes I know about type hinting, thats opt in and different), R doesnâ€™t do any validation of arguments. TypeScript can add a layer of Duck Typing checks to the functions which is great for them. But what about us? \n\nHow can we make our R functions safer? In R, (almost) everything is a vector.  The `r-lib` team has (very quietly) created what I think is the greatest contribution to the tidyverse ecosystem in a long time in the form of standalone type check functions. \n\n## Stand-alone type checks\n\nThe standalone functions are quite unique. Iâ€™ve never seen anything quite like them. Theyâ€™re literally standalone R files with a bunch of handy R functions. Itâ€™s like adding a package but without adding it as a dependency. \n\nThese are functions prefixed with `check_`  that test inputs for the most common types. They provide beautiful error messages and have commonly needed flexibility. \n\n### Add type checks to your project\n\nThe usethis package has a handy function `use_standalone()` which will add these functions for you. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_standalone(\"r-lib/rlang\", file = \"types-check\")\n```\n:::\n\n\nThis is supposed to be used in the context of an R package but can still be used in any R script. THe function requires an R directory to be found at the root. \n\n## Standalone type checks\n\nWe can get *really far* in enhancing type safety \n\n[https://usethis.r-lib.org/reference/use_standalone.html](https://usethis.r-lib.org/reference/use_standalone.html)\n\nSince this isn't an R package, I will source the functions. Otherwise, run `devtools::load_all()` for the functions to become available. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngetwd()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"/Users/josiahparry/github/quarto-site/posts/2024-06-30-type-safety\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsource(\"R/import-standalone-obj-type.R\", local = TRUE)\nsource(\"R/import-standalone-types-check.R\", local = TRUE)\nlibrary(rlang)\n```\n:::\n\n\n:::{.callout-note}\nThese standalone checks require that `{rlang}` be an imported package. Use `usethis::use_package(\"rlang\")`. It is a very small package and has no dependencies. Very little to lose by adding it. \n:::\n\n\n## Scalar checks \n\nR doesn't have the concept of a scalar. Though using a scalar is still very useful in R. \n\nThe standalone checks provide helpers for checking scalar values. There a quite a few but the ones I use most commonly are:\n\n- `check_string()`\n- `check_bool()`\n- `check_number_whole()`\n- `check_number_decimal()`\n\n### Usage\n\nEach of these functions provide the arguments: \n\n- `allow_na`\n- `allow_null`\n\nThis is helpful because using NULL is often used as a default argument for optional arguments. \n\nFor example we can check that something is a string: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_string(\"a\")\n```\n:::\n\n\nBut when it is a character vector: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_string(c(\"hello\", \"world\"))\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! `c(\"hello\", \"world\")` must be a single string, not a character vector.\n```\n\n\n:::\n:::\n\n\nThis gives us an informative error telling the user what type was found and expected.\n\nIn the case of `NULL`s we can provide the `allow_null` argument which allows the test to pass. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_string(NULL)\ncheck_string(NULL, allow_null = TRUE)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n## Vector checks\n\nIn addition to scalar checks, there are many handy vectorized checks.\n\nThere are vector checks these are: \n\n- `check_character()`\n- `check_logical()`\n- `check_data_frame()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_character(1:2)\ncheck_logical(c(\"a\", \"b\"))\ncheck_data_frame(list(a = 1, b = 2))\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! `1:2` must be a character vector, not an integer vector.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! `c(\"a\", \"b\")` must be a logical vector, not a character vector.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! `list(a = 1, b = 2)` must be a data frame, not a list.\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}