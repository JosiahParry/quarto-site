{
  "hash": "3ebef61b2ed2892a52499c844963a38d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Shared segment of parallel lines\"\ndate: \"2024-01-27\"\ncategories: [r-spatial, spatial]\n---\n\n\n## I need your help!!\n\nI am working on a problem where I identify approximately parallel lines. From the two lines that I have deemed parallel, I want to calculate the length of the segment that has a shared domain or range, or both domain and range. \n\nIn these examples I am using truly parallel lines for sake of simplicity. \n\nThere are four scenarios that we have to solve for: positive slope, negative slope, no slope, and undefined slopes. \n\n**Helper functions: **\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n# calculate range of x values \nx_range <- function(x) {\n  bbox <- sf::st_bbox(x)\n  return(c(bbox$xmin, bbox$xmax))\n}\n\n# calculate range of y values \ny_range <- function(x) {\n  bbox <- sf::st_bbox(x)\n  return(c(bbox$ymin, bbox$ymax))\n}\n\n# calculate overlapping range between two ranges\noverlap_range <- function(r1, r2) {\n  if (r1[2] < r2[1] || r2[2] < r1[1]) {\n    return(NA)\n  } else {\n    return(c(max(r1[1], r2[1]), min(r1[2], r2[2])))\n  }\n}\n\nfind_overlaps <- function(a, b) {\n  list(\n    x_overlap = overlap_range(x_range(a), x_range(b)),\n    y_overlap = overlap_range(y_range(a), y_range(b))\n  )\n}\n\noverlap_rect <- function(x) {\n  bbox <- sf::st_bbox(\n    c(\n      xmin = x$x_overlap[1], \n      xmax = x$x_overlap[2],\n      ymin = x$y_overlap[1],\n      ymax = x$y_overlap[2]\n    )\n  )\n  sf::st_as_sfc(bbox)\n}\n```\n:::\n\n\n\n\n\n## Positive Slope\n\nThe first scenario is the shared positive slope. \n\n**Question**:\n\nHow do I find the coordinates of the contained line segment to calculate the length? The solution should be able to handle the scenario where x and y are flipped as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Positive Slope Scenario\nx <- wk::wkt(\n  c(\n    \"LINESTRING(0.0 0.0, 2.0 2.0)\", # target line\n    \"LINESTRING(0.5 0.75, 2.5 2.75)\" # one we've deemed parallel\n  )\n) \nplot(x)\n```\n\n::: {.cell-output-display}\n![](2024-01-27-shared-segments_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWe can see that these two lines are parallel. We find their overlapping range:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap <- find_overlaps(x[1], x[2])\noverlap\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x_overlap\n[1] 0.5 2.0\n\n$y_overlap\n[1] 0.75 2.00\n```\n\n\n:::\n:::\n\n\nWhat we want to calculate is the length of the red line segment contained by the bounding box.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x, col = c(\"red\", \"black\"))\nplot(overlap_rect(overlap), add = TRUE)\n```\n\n::: {.cell-output-display}\n![](2024-01-27-shared-segments_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n# Negative Slope Scenario\n\nWe have a very similar scenario. But this time with a _negative_ slope. The solution should be able to handle if I want to find each line segment if x and y are swapped.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- wk::wkt(\n  c(\n    \"LINESTRING(0 2, 2 0)\", # target line\n    \"LINESTRING(1 0.5, 3 -1.5)\" # deemed parallel\n  )\n)\n\n(overlap <- find_overlaps(x[1], x[2]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x_overlap\n[1] 1 2\n\n$y_overlap\n[1] 0.0 0.5\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(x)\nplot(overlap_rect(overlap), border = \"red\", add = TRUE)\n```\n\n::: {.cell-output-display}\n![](2024-01-27-shared-segments_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n\n# Undefined Slope Scenario\n\nHere, our overlap is only in one dimension as opposed to two. It may be more simple? \n\nI think the answer here is is `y_max - y_min`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- wk::wkt(\n  c(\n    \"LINESTRING(2 1.5, 2 2.5)\", # the target line \n    \"LINESTRING(1 1, 1 2)\", # deemed parallel\n    \"LINESTRING(2 1.5, 2 2)\" # overlap range (1D)\n  )\n)\n\n(overlap <- find_overlaps(x[1], x[2]))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x_overlap\n[1] NA\n\n$y_overlap\n[1] 1.5 2.0\n```\n\n\n:::\n\n```{.r .cell-code}\nplot(x[1:2])\nplot(x[3], lwd = 3, lty = 1, col = \"red\", add = TRUE)\n```\n\n::: {.cell-output-display}\n![](2024-01-27-shared-segments_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n**Segment Length**: \n\nHere is how we can calculate the overlap in the y-dimension: \n\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap <- find_overlaps(x[1], x[2])\ny_over <- overlap$y_overlap\ny_over[2] - y_over[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5\n```\n\n\n:::\n:::\n\n\n# No slope scenario\n\nSimilar to the undefined slope. We have a one dimensional overlap. I think the answer here is `x_max - x_min`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- wk::wkt(\n  c(\n    \"LINESTRING(0 1, 2 1)\", # target feature\n    \"LINESTRING(1 2, 3 2)\", # deemed parallel\n    \"LINESTRING(1 1, 2 1)\" # overlap range (1D)\n  )\n)\n\n\nplot(x[1:2])\nplot(x[3], lwd = 3, lty = 1, col = \"red\", add = TRUE)\n```\n\n::: {.cell-output-display}\n![](2024-01-27-shared-segments_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n**Segment Length**: \n\nHere is how we can calculate the overlap in the x-dimension: \n\n\n::: {.cell}\n\n```{.r .cell-code}\noverlap <- find_overlaps(x[1], x[2])\nx_over <- overlap$x_overlap\nx_over[2] - x_over[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n:::\n",
    "supporting": [
      "2024-01-27-shared-segments_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}