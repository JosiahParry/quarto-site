{
  "hash": "c6e441199a6745cc955b022f6ad2e910",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Read a CSV in a production API\"\ndate: \"2024-06-25\"\nsubtile: \"{plumber} and multipart request #RinProd\"\ncategories: [plumber, r, prod]\n---\n\n\nDeploying RESTful APIs is the way to put any language into production. R is not any different. \n\nOne challenge when making APIs is handling files.\n\nUploading files is done typically with a [_multipart request_](https://swagger.io/docs/specification/describing-request-body/multipart-requests/).  \n\n> \"[they] combine one or more sets of data into a single bodyâ€¦. You typically use these requests for file uploads and for transferring data of several types in a single request (for example, a file along with a JSON object).\"\n\n:::{.aside}\n[source: Swagger doc](https://swagger.io/docs/specification/describing-request-body/multipart-requests/)\n:::\n\n## Handling multipart requests in R\n\nYou can process them using the [`{mime}`](https://github.com/yihui/mime) package.\n\n:::{.aside}\nNamed after [\"mime types\"](https://en.wikipedia.org/wiki/Media_type) not [Mr. Mime](https://www.pokemon.com/us/pokedex/mr-mime)\n:::\n\n[`{plumber}`](https://rplumber.io) provides access to the body of a request using the `req` argument. \n\n```r\n#* @post /upload\nupload <- function(req, res) {\n    # body\n}\n```\n\nTo access the structure of request use [`mime::parse_multipart(req)`](https://rdrr.io/github/yihui/mime/man/parse_multipart.html). \n\nModifying the function like so will return json from the API\n\n```r\n#* @post /upload\nupload <- function(req, res) {\n    mp <- mime::parse_multipart(req)\n    mp\n}\n```\n\n**Save this as plumber.R**\n\n### Run your API\n\nIn your terminal (from the same working directory as `plumber.R`) run `R -e 'plumber::plumb(\"plumber.R\")$run(port = 3000)'`\n\nThis will give you a background API to call. \n\n## Making a multipart request\n\nUse [`httr2`](https://httr2.r-lib.org) to create the multipart request. \n\n- Start the request with `request()`\n- Base the request object to `req_body_multipart()` to add data \n- Use key-value pairs to `req_body_multipart(...)` to add data\n    - Note that values must be a string so create the json yourself\n- Send the request using `req_perform()`\n\n\nHere we give it a unique ID and add a sample of data \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr2)\n\nresp <- request(\"http://127.0.0.1:3000/upload\") |>\n  req_body_multipart(\n    id = ulid::ulid(),\n    sample = jsonify::to_json(sample(1:100, 10), unbox = TRUE)\n  ) |>\n  req_perform()\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRegistered S3 method overwritten by 'jsonify':\n  method     from    \n  print.json jsonlite\n```\n\n\n:::\n\n```{.r .cell-code}\nresp\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<httr2_response>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nPOST http://127.0.0.1:3000/upload\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nStatus: 200 OK\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nContent-Type: application/json\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nBody: In memory (81 bytes)\n```\n\n\n:::\n:::\n\n\nWe extract the data using `resp_body_string()` and process it using \n\n::: {.cell}\n\n```{.r .cell-code}\nresp_body_string(resp) |>\n  RcppSimdJson::fparse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$id\n[1] \"01J18XJPSG9WGMKGVEWVJZCP2Q\"\n\n$sample\n[1] \"[86,24,41,7,79,63,67,16,94,64]\"\n```\n\n\n:::\n:::\n\n\n## Adding files\n\nWe'll create a tempory file containing the `iris` data.frame and send this to the API endpoint.\n\nThese two lines: \n\n1. Create a temporary csv file\n2. Write the data frame to the temporary file \n\n:::{.callout-tip}\nThis is a very handy trick that you might be able to adapt to many other circumstances. Temporary files are _very_ useful. \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- tempfile(fileext = \".csv\")\nreadr::write_csv(head(iris), tmp)\n```\n:::\n\n\n\nNext we need to upload the file to our request. Do this using `curl::form_file()`. You need to provide a path to the file. In this case, it will be the temporary file. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp <- request(\"http://127.0.0.1:3000/upload\") |>\n  req_body_multipart(\n    file = curl::form_file(tmp)\n  ) |>\n  req_perform()\n\nresp_body_string(resp) |>\n  jsonify::pretty_json()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n{\n    \"file\": [\n        {\n            \"name\": \"file26e662f21324.csv\",\n            \"size\": 192,\n            \"type\": \"application/octet-stream\",\n            \"datapath\": \"/var/folders/wd/xq999jjj3bx2w8cpg7lkfxlm0000gn/T//Rtmpy4E9zE/file25d52285bb5b\"\n        }\n    ]\n}\n```\n\n\n:::\n:::\n\n\nIn this case `file` is a named list. `mime` stores the file in a temporary path accessible via `datapath`. So let's try adding an API endpoint to read a csv file. \n\n\n## Read CSV in Plumber API\n\n\nHere we read the csv from the path. We would probably need to add some better checks here. Like checking that the field actually exists in `mp` but the error will be propagates as a 500 status anyways. \n\nSomething is always better than nothing. Just like this blog post. \n\n```r\n#* @post /read_csv\nfunction(req, res) {\n  mp <- mime::parse_multipart(req)\n  readr::read_csv(mp$file$datapath)\n}\n```\n\n\n## Send CSV to API\n\nHere is how we can send the csv to the API\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp <- request(\"http://127.0.0.1:3000/read_csv\") |>\n  req_body_multipart(\n    file = curl::form_file(tmp)\n  ) |>\n  req_perform()\n\nresp_body_string(resp) |>\n  jsonify::pretty_json()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[\n    {\n        \"Sepal.Length\": 5.1,\n        \"Sepal.Width\": 3.5,\n        \"Petal.Length\": 1.4,\n        \"Petal.Width\": 0.2,\n        \"Species\": \"setosa\"\n    },\n    {\n        \"Sepal.Length\": 4.9,\n        \"Sepal.Width\": 3,\n        \"Petal.Length\": 1.4,\n        \"Petal.Width\": 0.2,\n        \"Species\": \"setosa\"\n    },\n    {\n        \"Sepal.Length\": 4.7,\n        \"Sepal.Width\": 3.2,\n        \"Petal.Length\": 1.3,\n        \"Petal.Width\": 0.2,\n        \"Species\": \"setosa\"\n    },\n    {\n        \"Sepal.Length\": 4.6,\n        \"Sepal.Width\": 3.1,\n        \"Petal.Length\": 1.5,\n        \"Petal.Width\": 0.2,\n        \"Species\": \"setosa\"\n    },\n    {\n        \"Sepal.Length\": 5,\n        \"Sepal.Width\": 3.6,\n        \"Petal.Length\": 1.4,\n        \"Petal.Width\": 0.2,\n        \"Species\": \"setosa\"\n    },\n    {\n        \"Sepal.Length\": 5.4,\n        \"Sepal.Width\": 3.9,\n        \"Petal.Length\": 1.7,\n        \"Petal.Width\": 0.4,\n        \"Species\": \"setosa\"\n    }\n]\n```\n\n\n:::\n:::\n\n\nNote that the response is just nice json.\n\nWe can parse that back doing a full round trip:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp_body_string(resp) |>\n  RcppSimdJson::fparse()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n```\n\n\n:::\n:::\n\n\n\n# Whole API:\n\n\n\n::: {.cell filename='plumber.R'}\n\n```{.r .cell-code}\nlibrary(plumber)\n# R -e 'plumber::plumb(\"plumber.R\")$run(port = 3000)'\n#* @post /upload\nupload <- function(req, res) {\n  mp <- mime::parse_multipart(req)\n  mp\n}\n\n#* @post /read_csv\nfunction(req, res) {\n  mp <- mime::parse_multipart(req)\n  readr::read_csv(mp$file$datapath)\n}\n```\n:::\n\n\n##  Scale your APIs\n\nUse [`Valve`](https://valve.josiahparry.com/) to scale and deploy your applications to production. \n\nIt kicks ass tbh. ",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}