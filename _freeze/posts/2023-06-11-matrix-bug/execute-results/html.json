{
  "hash": "f5eb10c79cae97b0236dae31e573e739",
  "result": {
    "markdown": "---\ntitle: \"What's so special about `array`s?\"\ndate: 2023-06-11\ncategories: [r]\n---\n\n\nI'm working on a new video about S3 objects in R and class inheritance / hierarchy. One of my favorite functions for exploring objecs and their structure is `unclass()`.\n\nThe documentation states  \n\n> `unclass` returns (a copy of) its argument with its class attribute removed. (It is not allowed for objects which cannot be copied, namely environments and external pointers.)\n\n::: {.aside}\nsee `?unclass` and review `Details`\n:::\n\nSo, `unclass()` _should_ remove the class of any and all objects. For the sake clarity of this post I'm going to make a helper function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_unclass <- function(x) class(unclass(x))\n```\n:::\n\n\n\nThis works for `factor`s which are just integer vectors which have the attribute `levels`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_unclass(factor())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\nand `data.frame`s are lists (also technically a vector just not atomic but instead recursive) with attributes `row.names`, and `names`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_unclass(data.frame())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"list\"\n```\n:::\n:::\n\n\nBut when we get down to `matrix` another poser type (just like data.frame and factor pretending to be something they're not actually), we get something different. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_unclass(matrix())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\nWell, why the heck is that? What about it makes it so special? Let's explore this a bit more. \n\nThe two things that make a matrix are the classes `c(\"matrix\", \"array\")` and the `dim` attribute which specifies the dimensions. Matrixes are two dimensional arrays, by the way! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(matrix())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$dim\n[1] 1 1\n```\n:::\n:::\n\n\nWhat is weird is that you can make a matrix just by adding the `dim` attribute to a vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- structure(integer(1), dim = c(1, 1))\nclass_unclass(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\nWe didn't even specify the class. Why does this happen?\n\nAnd when we remove the dim attribute....\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(m, \"dim\") <- NULL\nclass_unclass(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"integer\"\n```\n:::\n:::\n\n\nwe get an integer vector. This differs from the behavior of other similar types. Recall that factors are `integer` vectors with an attribute of `levels` that is a character vector. \n\nSo let's try something here. Let's create a factor from scratch. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(integer(), levels = character(), class = \"factor\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfactor()\nLevels: \n```\n:::\n:::\n\n\nNow, if the behavior is similar to `matrix` or `array` we would expect that by omitting the `class` attribute R should reconstruct it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(integer(), levels = character())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\nattr(,\"levels\")\ncharacter(0)\n```\n:::\n:::\n\n\nNope! Would you look at that! \n\n[**@yjunechoe**](https://github.com/yjunechoe) pointed me to some excerpts from [Deep R Programming](https://deepr.gagolewski.com/), a book I wish I had read yesterday. It refers to these attributes as \"_special attributes_\". The author, [Marek Gagolewski](https://www.gagolewski.com/) (author of [`stringi`](https://stringi.gagolewski.com/), by the way), makes note of this special behavior of matrix but leaves it at that. \n\nTo me, this is a fundamental inconsistency in the language. Either all poser types (data.frame, matrix, factor, etc) should be automatically created if their special attributes are set on the appropriate type or not at all. What justification is there for _only_ `matrix` having a special behavior in `unclass()`? \n\nTo me, this warrants a bug report for `unclass()`. Based on the documentation, `unclass()` should _always_ remove the class attribute from an object but it fails to do so for `arrays` and `matrix`es. \n\n\n## Looking deeper! \n\nWith some further exploratory help of June we can see the internal representation of these objects.\n\nLet's create an object with a `dim` attribute and a custom class. Suprisingly, the custom class is respected and `matrix` and `array` aren't slapped on it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- structure(integer(1), dim = c(1, 1), class = \"meep\")\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"meep\"\n```\n:::\n:::\n\n\nIf we look at the internal representation using `.Internal(inspect(x))` we get to see some of the C goodies.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.Internal(inspect(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@10ea6ccd0 13 INTSXP g0c1 [OBJ,REF(2),ATT] (len=1, tl=0) 0\nATTRIB:\n  @10f0d5570 02 LISTSXP g0c0 [REF(1)] \n    TAG: @13d00e880 01 SYMSXP g1c0 [MARK,REF(2905),LCK,gp=0x4000] \"dim\" (has value)\n    @10ea6cd08 13 INTSXP g0c1 [REF(65535)] (len=2, tl=0) 1,1\n    TAG: @13d00e9d0 01 SYMSXP g1c0 [MARK,REF(32428),LCK,gp=0x6000] \"class\" (has value)\n    @12d670170 16 STRSXP g0c1 [REF(65535)] (len=1, tl=0)\n      @12d6701a8 09 CHARSXP g0c1 [REF(2),gp=0x60] [ASCII] [cached] \"meep\"\n```\n:::\n:::\n\n\nJust look to the right hand side of these gibberish. See that the `dim` has a value of `1,1` and `class` has a value of `meep`. There is no matrix or array or nothing. \n\nNow we remove the `meep` class and check again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_unclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"matrix\" \"array\" \n```\n:::\n:::\n\n\nBoom matrix and array. But if we look at the internals...\n\n\n::: {.cell}\n\n```{.r .cell-code}\n.Internal(inspect(unclass(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n@10fa94200 13 INTSXP g0c1 [ATT] (len=1, tl=0) 0\nATTRIB:\n  @10f31f5d8 02 LISTSXP g0c0 [REF(1)] \n    TAG: @13d00e880 01 SYMSXP g1c0 [MARK,REF(2933),LCK,gp=0x4000] \"dim\" (has value)\n    @10ea6cd08 13 INTSXP g0c1 [REF(65535)] (len=2, tl=0) 1,1\n```\n:::\n:::\n\n\nTHEY AREN'T THERE!!!!!!",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}