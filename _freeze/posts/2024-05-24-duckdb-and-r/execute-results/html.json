{
  "hash": "2ac3837f14c2f0a31eb4f3946c567801",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"{duckdb} or {duckplyr}? \"\nsubtitle: \"DuckDB and the R ecosystem\"\ndate: \"2024-05-24\"\ncategories: [r, prod, duckdb]\nfreeze: true\n---\n\n\nI've been diving pretty deep into DuckDB. It has shown that it has great utility for the vast majority of mid to large scale data analysis tasksâ€”I'm talking Gigabytes not Petabytes. In particular, [Kirill MÃ¼ller](https://github.com/krlmlr) of [Cynkra](https://cynkra.com/), has been doing great work in bringing DuckDB to the R community. \n\nToday, this takes the form of two R packages: \n\n- [`{duckdb}`](https://r.duckdb.org/)\n- [`{duckplyr}`](https://duckdblabs.github.io/duckplyr/)\n\nI think the R community would **benefit greatly** by adopting DuckDB into their analytic workflows. It can used to make highly performant shiny applications or just speed up your workflow.\n\nFor example, here is a demo of a Shiny application filtering, plotting, and visualizing 4.5 million records very quickly! \n\n![](https://raw.githubusercontent.com/flrsh-dev/flrsh-lessons/main/duckdb-deep-dive/project/final-app.gif)\n\n:::{.callout-note collapse=\"true\"}\n## a personal note\nI'm beginning to build out some content for courses that I'll be making availble through my new website [flrsh.dev](https://flrsh.dev/) (pronounced flourish). Sign up if you want to be notified when we start rolling things out ðŸ™ƒ. \n\nThe first course will be on DuckDB! \n\nAlso, if it takes a while to load, thats because the provider is spinning up an instance because no one is on it lol! It is very much a **WIP**.\n:::\n\n\n## Y'all keep asking me `{duckdb}` or `{duckplyr}`\n\nand before I tell you what my answer is, I'll tell you why I'm bullish on DuckDB. I won't ramble on details. \n\n\n:::{.callout-tip collapse=\"true\"}\n## Jargon giraffe ðŸ¦’: bullish!\nBullish is a term that is associated with a growing stock market. Think of the upward motion of their horns. People who are \"bullish\" would spend more money in the stock market expecting its prices to continue to rise and thus make more moneyyy ðŸ’¸ðŸ’¸ðŸ’¸\n:::\n\n## Why DuckDB?\n\n- Supports **larger-than-memory** workloads\n- Columnar vectorized operations means **operating only on the data you need** to and more of it and faster!\n- Tight [Apache Arrow](https://arrow.apache.org/docs/r/) integration!\n- Supports [Substrait](https://substrait.io/) for database agnostic query plans \n- Runs in the browser (think [ShinyLive](https://shinylive.io/r/examples/) + DuckDB means fast compute all running in the browser without a Shiny server)\n- _ It is stupid fast_\n\n## My verdict?\n\nThe thing that is most important, in my opinion, for DuckDBs ability to be useful to the R community is its ability to work on data that is larger than RAM. [Read this awesome blog post](https://duckdb.org/2024/03/29/external-aggregation.html).\n\n:::{.display-1}\n> Use `{duckdb}`!!!\n:::\n\n### `{duckplyr}`\n\nThe R package `{duckplyr}` is a **drop in replacement for dplyr**. duckplyr operates only on data.frame objects and, as of today, only works with in memory data. This means it is limited to the size of your machine's RAM. \n\n\n### `{duckdb}`\n\n`{duckdb}`, on the other hand, is a [`{DBI}`](https://dbi.r-dbi.org/reference/index.html) extension package. This means that you can use DBI functions to write standard SQL. But it also means that you can use use tables in your DuckDB database with dplyr (via dbplyr).\n\n`{duckdb}` allows you to write standard dplyr code and create lazy tables that can be combined to make even lazier code! Moreover, you can utilize the **out-of-core** processing capabilities with DuckDB using `{duckdb}` and, to me, that is the whole selling point. \n\nIf performance is your objective and you, for some reason, refuse to use the out-of-core capabilities of DuckDB, you should just use `data.table` via `dtplyr`. \n\n\n\n## Getting started with DuckDB & R\n\nUsing DuckDB as a database backend for dplyr is pretty much the same as anything other backend you might use. Very similar code to what I'll show you can be used to run code on Apache Spark or Postgres. \n\n:::{.callout-note collapse=\"true\"}\n## ðŸ˜­ * crying * just use postgres\n<blockquote class=\"twitter-tweet\"><p lang=\"en\" dir=\"ltr\">me, sobbing: just use postgres <a href=\"https://t.co/rJ4JcZJ4Zj\">https://t.co/rJ4JcZJ4Zj</a></p>&mdash; Jacob Matson (@matsonj) <a href=\"https://twitter.com/matsonj/status/1793681468134445371?ref_src=twsrc%5Etfw\">May 23, 2024</a></blockquote> <script async src=\"https://platform.twitter.com/widgets.js\" charset=\"utf-8\"></script>\n\n\n```\n|ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£ï¿£|\n    Just use Postgres    \n|ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿|\n       \\ (â€¢â—¡â€¢) / \n        \\     /\n```\n:::\n\n### Create a DuckDB driver\n\n1. Load duckdb: `library(duckdb)`\n2. Create a database driver `duckdb()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(duckdb)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: DBI\n```\n\n\n:::\n\n```{.r .cell-code}\n# This uses **in memory** database which is limited by RAM\ndrv <- duckdb()\n\n# this creates a persistent database which allows DuckDB to\n# perform **larger-than-memory** workloads\ndrv <- duckdb(tempfile(fileext = \".duckdb\"))\ndrv\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<duckdb_driver dbdir='/private/var/folders/wd/xq999jjj3bx2w8cpg7lkfxlm0000gn/T/Rtmpt7T0Xr/file84ac2528edf1.duckdb' read_only=FALSE bigint=numeric>\n```\n\n\n:::\n:::\n\n\n3. Create a database connection object\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncon <- dbConnect(drv)\ncon\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n<duckdb_connection 949a0 driver=<duckdb_driver dbdir='/private/var/folders/wd/xq999jjj3bx2w8cpg7lkfxlm0000gn/T/Rtmpt7T0Xr/file84ac2528edf1.duckdb' read_only=FALSE bigint=numeric>>\n```\n\n\n:::\n:::\n\n\n4. Import some data from somewhere\n\nHere we will download a medium sized csv and import it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- tempfile(fileext = \".csv\")\ndownload.file(\n  \"https://raw.githubusercontent.com/flrsh-dev/flrsh-lessons/main/data/houses1990.csv\",\n  tmp\n)\n\nhousing <- tbl_file(con, tmp)\nhousing\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Source:   SQL [?? x 9]\n# Database: DuckDB v0.10.2 [root@Darwin 23.4.0:R 4.4.0//private/var/folders/wd/xq999jjj3bx2w8cpg7lkfxlm0000gn/T/Rtmpt7T0Xr/file84ac2528edf1.duckdb]\n   houseValue income houseAge rooms bedrooms population households latitude\n        <dbl>  <dbl>    <dbl> <dbl>    <dbl>      <dbl>      <dbl>    <dbl>\n 1     452600   8.33       41   880      129        322        126     37.9\n 2     358500   8.30       21  7099     1106       2401       1138     37.9\n 3     352100   7.26       52  1467      190        496        177     37.8\n 4     341300   5.64       52  1274      235        558        219     37.8\n 5     342200   3.85       52  1627      280        565        259     37.8\n 6     269700   4.04       52   919      213        413        193     37.8\n 7     299200   3.66       52  2535      489       1094        514     37.8\n 8     241400   3.12       52  3104      687       1157        647     37.8\n 9     226700   2.08       42  2555      665       1206        595     37.8\n10     261100   3.69       52  3549      707       1551        714     37.8\n# â„¹ more rows\n# â„¹ 1 more variable: longitude <dbl>\n```\n\n\n:::\n:::\n\n\n5. Run some dplyr code on the table\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\navg_price_by_age <- housing |>\n  group_by(houseAge) |>\n  summarise(\n    avg_val = mean(houseValue)\n  )\n\nshow_query(avg_price_by_age)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT houseAge, AVG(houseValue) AS avg_val\nFROM (FROM '/var/folders/wd/xq999jjj3bx2w8cpg7lkfxlm0000gn/T//Rtmpt7T0Xr/file84ac12eaa270.csv') q01\nGROUP BY houseAge\n```\n\n\n:::\n:::\n\n\n6. Bring the results into memory \n\nUse `dplyr::collect()` to bring the results into memory as an actual tibble! \n\n::: {.cell}\n\n```{.r .cell-code}\navg_price_df <- collect(avg_price_by_age)\navg_price_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52 Ã— 2\n   houseAge avg_val\n      <dbl>   <dbl>\n 1       17 190494.\n 2       35 207299.\n 3       37 207361.\n 4       44 216233.\n 5       30 200253.\n 6       14 189597.\n 7        5 208418.\n 8        9 186673.\n 9       21 200157.\n10       25 220414.\n# â„¹ 42 more rows\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}