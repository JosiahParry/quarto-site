{
  "hash": "7840d0386181ca1a6659a4dba5cdf6bb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"ðŸŽ„dvent Day 1: Rust and R solutions\"\nauthor: Josiah Parry\ndate: 2024-12-01\ncategories: [r, rust, aoc]\n---\n\n\n\n## TL;DR\n\nI give you the solutions to Day 1 of Advent of Code in R, Rust, and Rust in R for part 2 using [`{extendr}`](https://extendr.github.io/user-guide/complete-example.html).\n\n---------\n\n\nI tend to always do just the first day of the advent of code. It is not my cup of tea. I don't enjoy word problems, or sudoku, or the like. But I do like it when people learn. I find many people use this as a time to learn a new language.\n\nThis morning I did the [Advent of Code Day 1](https://adventofcode.com/2024/day/1) in both R and Rust. I'll discuss my approaches to the challenges. \n\n:::{.callout-important}\nIf you care a lot about the Advent of Code and want to do it yourself, do not read any further. \nI am giving away the answers.\n:::\n\n## Part 1\n\nThe objective of part one is to calculate the distance between column 1 and column 2 in acending order. Note that the distance is in **absolute** values. This is not mentioned but I figured it out after my first submission was wrong. \n\nThe approach: \n\n- read input\n- sort each column independently\n- calculate the different from column 2 and column 1\n- calculate the absolute value\n- sum it all up \n\n### R \n\nThis was a one liner: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(abs(do.call(`-`, lapply(read.table(\"day1.txt\"), sort))))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2057374\n```\n\n\n:::\n:::\n\n\nLet's try rewriting it using a pipe so it can be a bit easier to process: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.table(\"day1.txt\") |> \n  lapply(sort) |> \n  do.call(`-`, args = _) |> \n  abs() |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2057374\n```\n\n\n:::\n:::\n\n\nThere are two things here that may be novel to you. The first is that we can use `lapply()` with a `data.frame`. \n\nTo quote myself: \n\n> \"Data frames are actually just lists masquerading as rectangles.\" \n\nSource: [Finding and SPSS {haven}](https://josiahparry.com/posts/2019-12-14-spss-haven)\n\nThis returns a list where each element is the sorted input vector. \n\nNext, we can compute the different between the two columns by using `do.call()` with the function being `-`. `do.call()` takes a list of arguments and splices them into the function call. \n\nSince our funciton, `-`, has two arguments it works perfectly. Then we wrap the results in `sum(abs())` and voila.\n\n### Rust\n\nThe hardest part of the rust solution is reading the file to be completely honest. I'm still terrible with using readers in Rust so I used ChatGPTs help. I'm not going to lie about it. \n\n#### Reading the input\n\nThe first thing to note is that we are returning `Result<(Vec<i32>, Vec<i32>), Box<dyn Error>>` from the function. We return a `Result<>` because there are multiple places where the function can error. Using a `Result<>` gives us the ability to unwrap anything inside of the body of the function that is in a `Result<>` itself. If there is an error, it will be returnedâ€”thus, \"gracefully\" handling the errors. \n\nTypically, if you're a Rust hardo, you will define your own custom `Error` type. That is too much work for meâ€”and I'm not good at knowing all of the types of errors that I may want. Instead we use `Box<dyn Error>`. `Box<dyn Error>` is a fancy way of saying we can accept anything that implements the `Error` trait. \n\nNext it is important to use a `BufReader` which allows us to read the file line by line. _Always_ use a `BufReader` when possible. It will make your code so much faster. \n\nNext, we are going to instantiate two vectors that we will use to store the results. Then we iterate through the lines of the reader and parse the contents and shove them into the vector. Voila. \n\n\n\n::: {.cell}\n\n```{.rust .cell-code}\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn read_day1(path: &str) -> Result<(Vec<i32>, Vec<i32>), Box<dyn Error>> {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n\n    // Create two vectors to hold the integers\n    let mut vec1 = Vec::new();\n    let mut vec2 = Vec::new();\n\n    // Read the file line by line\n    for line in reader.lines() {\n        let line = line?;\n        let mut nums = line\n            .split_whitespace() // Split by whitespace\n            .map(|s| s.parse::<i32>()); // Parse each number into i32\n\n        // Collect the numbers into the two vectors\n        if let (Some(Ok(num1)), Some(Ok(num2))) = (nums.next(), nums.next()) {\n            vec1.push(num1);\n            vec2.push(num2);\n        } else {\n            eprintln!(\"Skipping malformed line: {}\", line);\n        }\n    }\n\n    Ok((vec1, vec2))\n}\n```\n:::\n\n\n#### Sorting and summing\n\nNext, we define a little handy wrapper function. We can use destructuring assignment here to put the results of `read_day1()` into two items at once. If you're an R user, this is like using [`{dotty}`](https://kevinushey.github.io/dotty/) or [`{zeallot}`](https://github.com/r-lib/zeallot). My preference is for dotty, personally. \n\n\n::: {.cell}\n\n```{.rust .cell-code}\npub fn day_one_part_one(path: &str) -> Result<i32, Box<dyn Error>> {\n    // read the input. needs to be mutable to sort\n    let (mut x, mut y) = read_day1(path)?;\n\n    // sort the input\n    x.sort();\n    y.sort();\n\n    // calculate the sum\n    let res = x.iter().zip(y.iter()).fold(0, |mut acc, (xx, yy)| {\n        acc += (yy - xx).abs();\n        acc\n    });\n\n    Ok(res)\n}\n```\n:::\n\n\nWe iterate through x **and** why by creating a `zipped` iterator. When you zip an iterator you get a tuple of elements. We will iterate through these two items together and calculate the absolute difference and accumulate it along the way. \n\nWe accumulate the results using `.fold()` which takes two arguments :\n\n1. The initial value to accumulate\n2. A closure that has two arguments: \n  1. The accumulating value\n  2. The current value of the iterator\n\nA closure is like an anonymous function in R that is defined like `\\(.x, .y)` or using the `purrr` tilde syntax like `~ .x + .y`.\n\nIt is also important that the closure must return the same type as the initial value. \n\nIn our closure we say that the `acc` (you can choose any name you'd like here, it is just a function argument) must be mutable so we can change its value at each step. We use the shortcut `+=` operator so that we dont have to write `acc = acc + (yy - xx).abs()`. \n\n#### All together\n\nSince these are just functions, we need to wrap them all up in our `main.rs` file. \n\n\n::: {.cell filename='main.rs'}\n\n```{.rust .cell-code}\nuse std::error::Error;\n\nfn main() -> Result<(), Box<dyn Error>> {\n    let d1p1 = day_one_part_one(\"input/day1.txt\")?;\n    println!(\"Part 1: {d1p1}\");\n    Ok(())\n}\n```\n:::\n\n\n## Part 2\n\nPart two was quite fun to do, actually. For it, we want to count the number of times that each value in the second column occurs. Each of these values correspond to a value in the first column. Our sum is now the value in column 1 multiplied by the number of times it occurs in column two. To approach this we will do the following: \n\n- read the input\n- count the number of times each value in column 2 occurs\n- calculate the \"score\" for each value in column 1\n- sum up the scores\n\n\n### R \n\nThe R solution is quite straight forward as well but again, might use techniques you're not familiar with. Here is the solution in all of its (surprisingly fast) glory. \n\nYou may think it is ugly but I _assure you_, it is very fast. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- read.table(\"day1.txt\")\nsum(x$V1 * table(x$V2)[as.character(x$V1)], na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23177084\n```\n\n\n:::\n:::\n\n\nLet's break it up. The most important part is the `table()` call. This calculates how many times each value in `x$V2` occurs. We can use this table as a lookup vector. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlookup <- table(x$V2)\n```\n:::\n\n\nUsing a lookup vector is a very efficient approach that people tend to not think about. Since this is a named vector, we can extract it's elements by name. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlookup[\"92252\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n92252 \n   19 \n```\n\n\n:::\n:::\n\n\nNow, all we need to do is do this for _every_ value in `x$V1`. We have to cast `x$V1` as a character vector otherwise it will attempt to do the lookup by position. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx_counts <- lookup[as.character(x$V1)]\ntail(x_counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n <NA>  <NA>  <NA>  <NA>  <NA> 61539 \n                                 11 \n```\n\n\n:::\n:::\n\n\nIf there is not any occurrences in `x$V2` the value is `NA` which is very handy because an `NA` just like a `0` will propagate in multiplication. All we need to do now is multiple and sum! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(x$V1 * x_counts, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23177084\n```\n\n\n:::\n:::\n\n\n### Rust\n\nI quite enjoyed writing this rust solutionâ€”frankly more than either R or Rust solution. Any time I get to use a `BtreeMap` I'm giddy.\n\nCounting unique values in Rust is a little bit different. We typically use a `Map` of some variety. Think of these as named lists. Typically you will hear reference about a `HashMap`. `HashMap` are key-value stores that do not have any sense of order in the key. `BTreeMap` is different because the key _must_ be ordered. Since we will be performing a lookup based on an integer value, I feel BTreeMap may be better hereâ€”though only bench marks can prove it one way or another. \n\nHere is the solution: \n\n::: {.cell}\n\n```{.rust .cell-code}\npub fn day_one_part_two(path: &str) -> Result<i32, Box<dyn Error>> {\n    // read the inputs\n    let (x, y) = read_day1(path)?;\n\n    // Create an empty BTreeMap to count the occurrences\n    let mut counts = BTreeMap::new();\n\n    // Iterate through Y to populate the BTreeMap and increment\n    // each time we see an entry\n    for yi in y {\n        let entry = counts.entry(yi).or_insert(0);\n        *entry += 1;\n    }\n\n    // Iterate through x and get the value from the btreemap.\n    // if it doesn't exist we get use the default value of 0\n    // that is what the unwrap_or() is for\n    let res = x.iter().fold(0, |mut acc, next| {\n        let multiplier = counts.get(next).unwrap_or(&0);\n        acc += next * multiplier;\n        acc\n    });\n\n    Ok(res)\n}\n```\n:::\n\n\nWe instantiate an empty `BTreeMap` then we populate it. We do this using the below code. This will grab the entry with the key `yi` from the map. If it doesn't exist, it will insert the value `0`. Then we add the value `1` to it. Notice that `*entry`. We do this because we are assinging to a mutable reference. This lets the value inside of the `counts` `BTreeMap` be updated. \n\n\n\n::: {.cell}\n\n```{.rust .cell-code}\n  for yi in y {\n      let entry = counts.entry(yi).or_insert(0);\n      *entry += 1;\n  }\n```\n:::\n\n\nThe next part is quite like our part 1 solution. We use `.fold()` to perform the sum for us. We iterate through each value of `x`â€”stored in the value of `next` in the closure. We then try and get the lookup value from our `counts` map. If there is no associated value, we provide a value of `0` and store it in our `multiplier` variable. Then we multiply `xi` (or `next` in the closure) and add it the the accumulator! \n\n\n\n::: {.cell}\n\n```{.rust .cell-code}\nlet res = x.iter().fold(0, |mut acc, next| {\n    let multiplier = counts.get(next).unwrap_or(&0);\n    acc += next * multiplier;\n    acc\n});\n```\n:::\n\n\nThat's it. While it is much more code, it feels much easier to read and a bit _cleaner_ than the R solution.\n\n\n## Bonus: R + Rust via `{rextendr}` {#rextendr}\n\nWe can take the part 2 solution and tidy it up into a Rust function that can be called from R using rextendr.\n\n:::{.callout-note} \nThis isn't optimized to be fast code and we're not even using R native types so we will incur an overhead cost to go from `integer()` vector to `Vec<i32>`.\n:::\n\nTo do this you will need `{rextendr}` installed. Do so with `pak::pak(\"extendr/rextendr\")`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntally_code <- r\"-{\n  fn tally_day1(x: Vec<i32>, y: Vec<i32>) -> Result<i32> {\n    let mut counts = std::collections::BTreeMap::new();\n    for yi in y {\n        let entry = counts.entry(yi).or_insert(0);\n        *entry += 1;\n    }\n\n    let res = x.iter().fold(0, |mut acc, next| {\n        let multiplier = counts.get(next).unwrap_or(&0);\n        acc += next * multiplier;\n        acc\n    });\n\n    Ok(res)\n}\n\n}-\"\n\nrextendr::rust_function(\n  tally_code, \n  profile = \"release\",\n  quiet = TRUE\n)\n```\n:::\n\n\nNow we can call this code directly from R: \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntally_day1(x$V1, x$V2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23177084\n```\n\n\n:::\n:::\n\n\nLet's perform a small bench mark between this and the R solution: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  r = sum(x$V1 * table(x$V2)[as.character(x$V1)], na.rm = TRUE),\n  rust_simple = tally_day1(x$V1, x$V2)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 Ã— 6\n  expression       min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr>  <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 r            353.1Âµs  376.5Âµs     2453.  226.78KB     10.5\n2 rust_simple   51.6Âµs   62.4Âµs    14025.    4.84KB      0  \n```\n\n\n:::\n:::\n\n\n## Rust solution code\n\nBelow is all of the code I used for the rust solution. \n\n::: {.panel-tabset}\n\n### `main.rs`\n\n\n::: {.cell filename='main.rs'}\n\n```{.rust .cell-code}\nuse std::error::Error;\n\nmod day1;\nuse day1::*;\nfn main() -> Result<(), Box<dyn Error>> {\n    let d1p1 = day_one_part_one(\"input/day1.txt\")?;\n    let d1p2 = day_one_part_two(\"input/day1.txt\")?;\n\n    println!(\"Day 1 results:\\n  Part 1: {d1p1}\\n  Part 2: {d1p2}\");\n    Ok(())\n}\n\n```\n:::\n\n\n\n### `day1.rs` \n\n\n\n::: {.cell filename='day1.rs'}\n\n```{.rust .cell-code}\nuse std::collections::BTreeMap;\nuse std::error::Error;\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn read_day1(path: &str) -> Result<(Vec<i32>, Vec<i32>), Box<dyn Error>> {\n    let file = File::open(path)?;\n    let reader = BufReader::new(file);\n\n    // Create two vectors to hold the integers\n    let mut vec1 = Vec::new();\n    let mut vec2 = Vec::new();\n\n    // Read the file line by line\n    for line in reader.lines() {\n        let line = line?;\n        let mut nums = line\n            .split_whitespace() // Split by whitespace\n            .map(|s| s.parse::<i32>()); // Parse each number into i32\n\n        // Collect the numbers into the two vectors\n        if let (Some(Ok(num1)), Some(Ok(num2))) = (nums.next(), nums.next()) {\n            vec1.push(num1);\n            vec2.push(num2);\n        } else {\n            eprintln!(\"Skipping malformed line: {}\", line);\n        }\n    }\n\n    Ok((vec1, vec2))\n}\n\npub fn day_one_part_one(path: &str) -> Result<i32, Box<dyn Error>> {\n    // read the input. needs to be mutable to sort\n    let (mut x, mut y) = read_day1(path)?;\n\n    // sort the input\n    x.sort();\n    y.sort();\n\n    // calculate the sum\n    let res = x.iter().zip(y.iter()).fold(0, |mut acc, (xx, yy)| {\n        acc += (yy - xx).abs();\n        acc\n    });\n\n    Ok(res)\n}\n\npub fn day_one_part_two(path: &str) -> Result<i32, Box<dyn Error>> {\n    // read the inputs\n    let (x, y) = read_day1(path)?;\n\n    // Create an empty BTreeMap to count the occurrences\n    let mut counts = BTreeMap::new();\n\n    // Iterate through Y to populate the BTreeMap and increment\n    // each time we see an entry\n    for yi in y {\n        let entry = counts.entry(yi).or_insert(0);\n        *entry += 1;\n    }\n\n    // Iterate through x and get the value from the btreemap.\n    // if it doesn't exist we get use the default value of 0\n    // that is what the unwrap_or() is for\n    let res = x.iter().fold(0, |mut acc, next| {\n        let multiplier = counts.get(next).unwrap_or(&0);\n        acc += next * multiplier;\n        acc\n    });\n\n    Ok(res)\n}\n```\n:::\n\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}