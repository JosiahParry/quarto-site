{
  "hash": "4d08792c9e25d53b34f39fc0ccf9fb73",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: S7 & Options objects\nsubtitle: reimagining `readr::read_csv()`\nauthor: Josiah Parry\ndate: 2024-11-21\ncategories: [pkg-dev, r, s7]\n---\n\n\nOne scenario I have encountered is the case case of `readr::read_delim()`. The argument `col_names = TRUE` by default, can be `FALSE`, or it can be a character vector of the names to provide to the columns it is reading. \n\nThis is a bit stinky ðŸ˜·. But it actually makes a lot of sense. \n\n- `col_names = TRUE` (default): the file provides you with headers and you should use them\n- `col_names = FALSE`: there are no column names we should make some placeholders for the data frame (because column names are necessary)\n- `col_names = character()`: we want to provide column names directly (makes the most sense when there are no headers in the file)\n\nThis is a little confusing when we think deeply about the character vector option. \n\nThere are two scenarios here: \n\n1. the file has column headers but we want to give it different ones \n2. the file has no column headers but we want to give it different ones\n\nLets explore how this works in practice a bit. Here we write `iris` to a temporary file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- tempfile(fileext = \".csv\")\nreadr::write_csv(iris, tmp)\n```\n:::\n\n\n### Scenario 1: has headers give it different once\n\n\n\n\n\nIn the first scenario we can provide a character vector to `col_names`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(tmp, col_names = c(\"a\", \"b\", \"c\", \"d\", \"e\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 151 Ã— 5\n   a            b           c            d           e      \n   <chr>        <chr>       <chr>        <chr>       <chr>  \n 1 Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n 2 5.1          3.5         1.4          0.2         setosa \n 3 4.9          3           1.4          0.2         setosa \n 4 4.7          3.2         1.3          0.2         setosa \n 5 4.6          3.1         1.5          0.2         setosa \n 6 5            3.6         1.4          0.2         setosa \n 7 5.4          3.9         1.7          0.4         setosa \n 8 4.6          3.4         1.4          0.3         setosa \n 9 5            3.4         1.5          0.2         setosa \n10 4.4          2.9         1.4          0.2         setosa \n# â„¹ 141 more rows\n```\n\n\n:::\n:::\n\n\nHere we can see that `col_names = character()` assumes that there isn't any header. \nTo accomplish this we need to set `skip = 1` to not read the first line where the header actually is. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\n    tmp,\n    col_names = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    skip = 1\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 Ã— 5\n       a     b     c     d e     \n   <dbl> <dbl> <dbl> <dbl> <chr> \n 1   5.1   3.5   1.4   0.2 setosa\n 2   4.9   3     1.4   0.2 setosa\n 3   4.7   3.2   1.3   0.2 setosa\n 4   4.6   3.1   1.5   0.2 setosa\n 5   5     3.6   1.4   0.2 setosa\n 6   5.4   3.9   1.7   0.4 setosa\n 7   4.6   3.4   1.4   0.3 setosa\n 8   5     3.4   1.5   0.2 setosa\n 9   4.4   2.9   1.4   0.2 setosa\n10   4.9   3.1   1.5   0.1 setosa\n# â„¹ 140 more rows\n```\n\n\n:::\n:::\n\n\n### Scenario 2: has no headers give it names\n\nCreate a csv without the headers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmp <- tempfile(fileext = \".csv\")\nreadr::write_csv(iris, tmp, col_names = FALSE)\n```\n:::\n\n\n:::{.aside}\nIn the case of `write_csv()` the argument `col_names` is _always_ a logical scalar\n:::\n\nIn this case, the `col_names = character()` works well! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv(\n    tmp,\n    col_names = c(\"a\", \"b\", \"c\", \"d\", \"e\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 Ã— 5\n       a     b     c     d e     \n   <dbl> <dbl> <dbl> <dbl> <chr> \n 1   5.1   3.5   1.4   0.2 setosa\n 2   4.9   3     1.4   0.2 setosa\n 3   4.7   3.2   1.3   0.2 setosa\n 4   4.6   3.1   1.5   0.2 setosa\n 5   5     3.6   1.4   0.2 setosa\n 6   5.4   3.9   1.7   0.4 setosa\n 7   4.6   3.4   1.4   0.3 setosa\n 8   5     3.4   1.5   0.2 setosa\n 9   4.4   2.9   1.4   0.2 setosa\n10   4.9   3.1   1.5   0.1 setosa\n# â„¹ 140 more rows\n```\n\n\n:::\n:::\n\n\nHere are the other two scenarios:\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\nreadr::read_csv(tmp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 149 Ã— 5\n   `5.1` `3.5` `1.4` `0.2` setosa\n   <dbl> <dbl> <dbl> <dbl> <chr> \n 1   4.9   3     1.4   0.2 setosa\n 2   4.7   3.2   1.3   0.2 setosa\n 3   4.6   3.1   1.5   0.2 setosa\n 4   5     3.6   1.4   0.2 setosa\n 5   5.4   3.9   1.7   0.4 setosa\n 6   4.6   3.4   1.4   0.3 setosa\n 7   5     3.4   1.5   0.2 setosa\n 8   4.4   2.9   1.4   0.2 setosa\n 9   4.9   3.1   1.5   0.1 setosa\n10   5.4   3.7   1.5   0.2 setosa\n# â„¹ 139 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nreadr::read_csv(tmp, col_names = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 150 Ã— 5\n      X1    X2    X3    X4 X5    \n   <dbl> <dbl> <dbl> <dbl> <chr> \n 1   5.1   3.5   1.4   0.2 setosa\n 2   4.9   3     1.4   0.2 setosa\n 3   4.7   3.2   1.3   0.2 setosa\n 4   4.6   3.1   1.5   0.2 setosa\n 5   5     3.6   1.4   0.2 setosa\n 6   5.4   3.9   1.7   0.4 setosa\n 7   4.6   3.4   1.4   0.3 setosa\n 8   5     3.4   1.5   0.2 setosa\n 9   4.4   2.9   1.4   0.2 setosa\n10   4.9   3.1   1.5   0.1 setosa\n# â„¹ 140 more rows\n```\n\n\n:::\n:::\n\n\n## Rethinking the arguments\n\nTo me, I think these arguments can be made less [complected](https://www.infoq.com/presentations/Simple-Made-Easy/).\n\nTo me, there are two arguments burried in `col_names`: \n\n1. `header = TRUE`\n2. `col_names = NULL`\n\nThe imaginary `header` argument should be used to determine if there is a header line to be used. \n\nThe `col_names`, which defaults to `NULL` can be used to provide an alternative set of column names. \n\nThis approach would reduce the cognitive overload of `col_names` argument. \n\nHowever, there are \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(formals(readr::read_csv))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20\n```\n\n\n:::\n:::\n\n\narguments already....so... additional ones? That could be quite a bit. \n\n\n## Options objects with S7\n\nOne alternative to having every option as a function argument is to create an options object. \n\nThis is very common in the Rust ecosystem. There is a struct that is used to define common settings. That object is then passed into methods and functions. \n\nWe could consider doing something similar for the `readr::read_csv()` function. \n\nLets take a look at the arguments for `readr::read_csv()` \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrlang::fn_fmls_names(readr::read_csv)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"file\"            \"col_names\"       \"col_types\"       \"col_select\"     \n [5] \"id\"              \"locale\"          \"na\"              \"quoted_na\"      \n [9] \"quote\"           \"comment\"         \"trim_ws\"         \"skip\"           \n[13] \"n_max\"           \"guess_max\"       \"name_repair\"     \"num_threads\"    \n[17] \"progress\"        \"show_col_types\"  \"skip_empty_rows\" \"lazy\"           \n```\n\n\n:::\n:::\n\n\nMany of these are booleans or scalars. I think we can improve this by using S7 to store our options as a standalone object.\n\n\nLooking at the arguments for `read_csv()` I think our options object can be used for the following options:\n\n- `locale`\n- `na`\n- `quote`\n- `comment`\n- `trim_ws`\n- `skip`\n- `n_max`\n- `guess_max`\n- `name_repair`\n- `num_threads`\n- `progress`\n- `show_col_types`\n- `skip_empty_rows`\n- `lazy`\n\nThis will take 14 of the less commonly used arguments out of the function! \n\nThe first thing we will do is define properties for each of these values. It looks like a lot of code, but it is not so bad! This boilerplate is going to give us a strongly typed object that will catch errors early! \n\n\n## S7 object properties\n\nFor each of the arguments we want to ensure that we: \n\n- have a good default\n- validate any input\n\nFirst we're looking at the `locale`. This one is quite a lot of checking.\n\n### Property validation\n\nIdeally, the `locale` would be an S7 object so we could provide a `class_locale` as our propery but we don't have that luxury. So here, we validate each of the components of the locale object. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(S7)\n\n.locale <- new_property(\n  class_list,\n  default = readr::default_locale(),\n  validator = function(value) {\n    dnames <- value$date_names\n    invalid <- !rlang::is_character(dnames$mon, n = 12) ||\n      !rlang::is_character(dnames$mon_ab, n = 12) ||\n      !rlang::is_character(dnames$day, n = 7) ||\n      !rlang::is_character(dnames$day_ab, n = 7) ||\n      !rlang::is_character(dnames$am_pm, n = 2) || !rlang::is_scalar_character(value$date_format) || !rlang::is_scalar_character(value$time_format) || !rlang::is_scalar_character(value$decimal_mark) || !rlang::is_scalar_character(value$grouping_mark) || !rlang::is_scalar_character(value$tz) || !rlang::is_scalar_character(value$encoding)\n\n    if (invalid) {\n      \"expected `locale` object\"\n    }\n  }\n)\n```\n:::\n\n\n\nSimilarly, the argument for `name_repair` is not at all straight forward. It can be one of any known strategy _or_ it can be a function that is applied to the names via `vctrs::vec_as_names()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n.name_repair <- new_property(\n  class_any,\n  default = \"unique\",\n  validator = function(value) {\n    known_strategies <- c(\"minimal\", \"unique\", \"check_unique\", \"unique_quiet\", \"universal\", \"universal_quiet\")\n\n    if (rlang::is_function(value)) {\n      fmls <- rlang::fn_fmls(value)\n      if (sum(vapply(fmls,inherits, logical(1),  \"name\")) > 1) {\n        \"name repair function must only have one required argument\"\n      }\n      return(NULL)\n    }\n\n    if (!rlang::is_scalar_character(value)) {\n      \"`name_repair` must be one of minimal, unique, check_unique, unique_quiet, universal, universal_quiet or a function\"\n    }\n\n    if (!value %in% known_strategies) {\n      sprintf(\"%s is not a valid `name_repair` value\")\n    }\n  }\n)\n```\n:::\n\n\nHere we define the validators for the rest of the options. These are all quite straight forward and are mostly scalars. \n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\n.na <- new_property(\n  class_character,\n  default = c(\"\", \"NA\")\n)\n\n.quote <- new_property(\n  class_logical, \n  default = TRUE,\n  validator = function(value) {\n      if (!rlang::is_scalar_logical(value)) {\n          \"`quote` must be a scalar character\"\n      }\n  }\n)\n\n\n.comment <- new_property(\n  class_character,\n  default = \"\\\"\",\n  validator = function(value) {\n    if (!rlang::is_scalar_character(value)) {\n      \"`comment` must be a scalar character\"\n    }\n  }\n)\n\n\n.trim_ws <- new_property(\n  class_logical, \n  default = TRUE,\n  validator = function(value) {\n      if (!rlang::is_scalar_logical(value)) {\n          \"`trim_ws` must be a scalar character\"\n      }\n  }\n)\n\n.skip <- new_property(\n  class_numeric,\n  default = 0L,\n  validator = function(value) {\n      if (!rlang::is_scalar_integerish(value)) {\n          \"`skip` must be a scalar numeric\"\n      }\n  }\n)\n\n.n_max <- new_property(\n  class_numeric,\n  default = Inf,\n  validator = function(value) {\n      if (!rlang::is_scalar_integerish(value)) {\n          \"`n_max` must be a scalar numeric\"\n      }\n  }\n)\n\n.guess_max <- new_property(\n  class_numeric,\n  default = 1000L,\n  validator = function(value) {\n      if (!rlang::is_scalar_integerish(value)) {\n          \"`guess_max` must be a scalar numeric\"\n      }\n\n  }\n)\n\n.n_max <- new_property(\n  class_numeric,\n  default = Inf,\n  validator = function(value) {\n      if (!rlang::is_scalar_integerish(value)) {\n          \"`n_max` must be a scalar numeric\"\n      }\n  }\n)\n\n.num_threads <- new_property(\n  class_numeric,\n  default = readr::readr_threads(),\n  validator = function(value) {\n      if (!rlang::is_scalar_integerish(value)) {\n          \"`num_threads` must be a scalar numeric\"\n      }\n  }\n)\n\n.progress <- new_property(\n    class_logical, \n    default = readr::show_progress(),\n    validator = function(value) {\n         if (!rlang::is_scalar_logical(value)) {\n          \"`progress` must be a scalar logical\"\n      }\n    }\n)\n\n.show_col_types <- new_property(\n    class_logical, \n    default = readr::should_show_types() %||% TRUE,\n    validator = function(value) {\n         if (!rlang::is_scalar_logical(value)) {\n          \"`show_col_types` must be a scalar logical\"\n      }\n    }\n)\n\n.skip_empty_rows <- new_property(\n    class_logical, \n    default = TRUE,\n    validator = function(value) {\n         if (!rlang::is_scalar_logical(value)) {\n          \"`skip_empty_rows` must be a scalar logical\"\n      }\n    }\n)\n\n\n.lazy <- new_property(\n    class_logical, \n    default = readr::should_read_lazy(),\n    validator = function(value) {\n         if (!rlang::is_scalar_logical(value)) {\n          \"`lazy` must be a scalar logical\"\n      }\n    }\n)\n```\n:::\n\n\n\n## S7 `readr_opts` class\n\nNow can actually define the S7 object class by passing in all of our new property objects to the `properties` argument. Because we defined defaults for every property we can construct a default option object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_readr_opts <- new_class(\n  \"readr_opts\",\n  properties = list(\n    locale = .locale,\n    na = .na,\n    quote = .quote,\n    comment = .comment,\n    trim_ws = .trim_ws,\n    skip = .skip,\n    n_max = .n_max,\n    guess_max = .guess_max,\n    name_repair = .name_repair,\n    num_threads = .num_threads,\n    progress = .progress,\n    show_col_types = .show_col_types,\n    skip_empty_rows = .skip_empty_rows,\n    lazy = .lazy\n  )\n)\n\nopts <- class_readr_opts()\nopts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<readr_opts>\n @ locale         :List of 7\n .. $ date_names   :List of 5\n ..  ..$ mon   : chr [1:12] \"January\" \"February\" \"March\" \"April\" ...\n ..  ..$ mon_ab: chr [1:12] \"Jan\" \"Feb\" \"Mar\" \"Apr\" ...\n ..  ..$ day   : chr [1:7] \"Sunday\" \"Monday\" \"Tuesday\" \"Wednesday\" ...\n ..  ..$ day_ab: chr [1:7] \"Sun\" \"Mon\" \"Tue\" \"Wed\" ...\n ..  ..$ am_pm : chr [1:2] \"AM\" \"PM\"\n ..  ..- attr(*, \"class\")= chr \"date_names\"\n .. $ date_format  : chr \"%AD\"\n .. $ time_format  : chr \"%AT\"\n .. $ decimal_mark : chr \".\"\n .. $ grouping_mark: chr \",\"\n .. $ tz           : chr \"UTC\"\n .. $ encoding     : chr \"UTF-8\"\n .. - attr(*, \"class\")= chr \"locale\"\n @ na             : chr [1:2] \"\" \"NA\"\n @ quote          : logi TRUE\n @ comment        : chr \"\\\"\"\n @ trim_ws        : logi TRUE\n @ skip           : int 0\n @ n_max          : num Inf\n @ guess_max      : int 1000\n @ name_repair    : chr \"unique\"\n @ num_threads    : int 8\n @ progress       : logi FALSE\n @ show_col_types : logi FALSE\n @ skip_empty_rows: logi TRUE\n @ lazy           : logi FALSE\n```\n\n\n:::\n:::\n\n\n\nWe can access each of these properties using the `@` accessor. For example, if we want the `locale`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nopts@locale\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<locale>\nNumbers:  123,456.78\nFormats:  %AD / %AT\nTimezone: UTC\nEncoding: UTF-8\n<date_names>\nDays:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday\n        (Thu), Friday (Fri), Saturday (Sat)\nMonths: January (Jan), February (Feb), March (Mar), April (Apr), May (May),\n        June (Jun), July (Jul), August (Aug), September (Sep), October\n        (Oct), November (Nov), December (Dec)\nAM/PM:  AM/PM\n```\n\n\n:::\n:::\n\n\n## Simplifying `readr::read_csv()` \n\nNow, imagine if we can use this as a way to simplify the `readr::read_csv()` function. The function definition can now look like: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv <- function(\n  file,\n  col_names = TRUE,\n  col_types = NULL,\n  col_select = NULL,\n  id = NULL,\n  options = class_readr_opts()\n) {\n    # function logic\n}\n```\n:::\n\n\nThis greatly reduces the cognitive load for end users and it consolides options specification into a single object. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}