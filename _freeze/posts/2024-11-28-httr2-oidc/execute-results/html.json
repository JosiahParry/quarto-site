{
  "hash": "b2171a11fd18ae6ca6ce8df153348a43",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Implementing OpenID Connect (OIDC) in R\"\ndate: 2024-11-28\nauthor: Josiah Parry\ncategories: [r,  httr2, auth, oidc]\n---\n\n\nI am working on a rust project that I want to use OpenID Connect for. I'm struggling to wrap my head around it, so naturally, I implemented it in R to understand it better. \n\n## What is OIDC? \n\n[OpenID Connect (OIDC)](https://openid.net/developers/how-connect-works/) is an authentication standard based on OAuth 2.0. The hope is that most identity providers (IDP) can have an implementation of OIDC so that plugging in their authentication system is pretty straight forward.\n\n## OIDC discovery\n\nEach OIDC provider has an `{issuer_url}/.well-known/openid-configuration` URL which contains information about the authentication provider. This is a public facing document that can be used to find endpoints and other information\n\nFor this example, I've created a free account at [Auth0](https://auth0.com/) and made an application. I'll store the url in a variable called `issuer_url` \n\n\n::: {.cell}\n\n```{.r .cell-code}\nissuer_url <- \"https://dev-2ts7ytkts28hfj4o.us.auth0.com\"\n```\n:::\n\n\nAccessing the `openid-configuration` is a simple get request. We'll create an `oidc_discovery()` function. This will return a list and we will give it a class `oidc_provider`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr2)\n\noidc_discovery <- function(issuer_url) {\n  res <- request(issuer_url) |>\n    req_url_path_append(\".well-known\", \"openid-configuration\") |> \n    req_perform() |>\n    resp_body_json()\n  structure(res, class = c(\"oidc_provider\", \"list\"))\n}\n```\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\nI've also given this object a nicer print method based on the `httr2_oauth_client` class in [`{httr2}`](https://httr2.r-lib.org).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.oidc_provider <- function(x, ...) {\n    # adapted from httr2:::print.httr2_request\n    cli::cli_text(cli::style_bold(\"<\", paste(class(x)[1], collapse = \"/\"), \">\"))\n    lines <- vapply(\n        x,\n        \\(.x) {\n        if (is.atomic(.x) && length(.x) == 1) {\n            if (is.character(.x)) {\n                paste0(\"'\", .x, \"'\")\n            }\n            else {\n                format(.x)\n            }\n        }\n        else {\n            class(.x)[1]\n        }\n        },\n        character(1)\n    )\n    cli::cli_dl(lines)\n    invisible(x)\n}\n```\n:::\n\n\n:::\n\nUsing this gives us a very informative list that we will use for identifying our authorization endpoints.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprovider <- oidc_discovery(issuer_url)\n```\n:::\n\n```\n<oidc_provider>\nissuer: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/'\nauthorization_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/authorize'\ntoken_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/oauth/token'\ndevice_authorization_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/oauth/device/code'\nuserinfo_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/userinfo'\nmfa_challenge_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/mfa/challenge'\njwks_uri: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/.well-known/jwks.json'\nregistration_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/oidc/register'\nrevocation_endpoint: 'https://dev-2ts7ytkts28hfj4o.us.auth0.com/oauth/revoke'\nscopes_supported: list\nresponse_types_supported: list\ncode_challenge_methods_supported: list\nresponse_modes_supported: list\nsubject_types_supported: list\ntoken_endpoint_auth_methods_supported: list\nclaims_supported: list\nrequest_uri_parameter_supported: FALSE\nrequest_parameter_supported: FALSE\nid_token_signing_alg_values_supported: list\ntoken_endpoint_auth_signing_alg_values_supported: list\nend_session_endpoint:\n'https://dev-2ts7ytkts28hfj4o.us.auth0.com/oidc/logout'\n```\n\nThe information in this object will be used for our oauth flows with `httr2`.\n\n## OIDC Client Object\n\nIn httr2, we create an `httr2_oauth_client` object to be used for our authentication flows. We will generalize that approac and create `oidc_client()`.\n\nIn this function, we will store the `redirect_uri` into the client itself as well as tack on the `oidc_client` subclass. This will give us a nicer print method and prevent us from having to put in the `redirect_uri` multiple times. \n\n\n::: {.cell}\n\n```{.r .cell-code}\noidc_client <- function(\n  oidc_provider,\n  client_id = Sys.getenv(\"OIDC_CLIENT\"),\n  client_secret = Sys.getenv(\"OIDC_SECRET\"),\n  redirect_uri = oauth_redirect_uri()\n) {\n  client <- oauth_client(\n    id = client_id,\n    secret = client_secret,\n    token_url = oidc_provider[[\"token_endpoint\"]]\n  )\n  client[[\"redirect_uri\"]] <- redirect_uri\n  class(client) <- c(\"oidc_client\", class(client))\n  client\n}\n```\n:::\n\n\nThis function fetches the client id and secret from environment variables. This is because we do not want to store these variables directly in our code. \n\n:::{.callout-tip}\nUse `usethis::edit_r_environ()` to set these variables globally. \nAlternatively, you can use something like `config` to have a `config.yml` file or an alternative environment management system. But at the end of the day just please do not store your credentials in your code!!!!\n:::\n\nFor Auth0, you have to specify which redirect URIs can be trusted. In my case I set it to `http://localhost:3000/oauth/callback` in my application settings. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclient <- oidc_client(\n    provider,\n    redirect_uri = \"http://localhost:3000/oauth/callback\"\n)\n```\n:::\n\n```\n<oidc_client/httr2_oauth_client>\nname: bf83aacb811320e5da430601736f1286\nid:\nsecret: <REDACTED>\ntoken_url: https://dev-2ts7ytkts28hfj4o.us.auth0.com/oauth/token\nauth: oauth_client_req_auth_body\nredirect_uri: http://localhost:3000/oauth/callback\n```\n\nThis client will now be used for our authentication steps.\n\n## OAuth2 Code Flow\n\nThe most secure method of authentication with OAuth2 is the code flow. This is also the most common when building web applications. It will send you to the external provider to authenticate there, then return you to the app when complete with an `access_token` and an `id_token`.\n\nHere we create the `oidc_flow_auth_code()` function. The authorization endpoint will likely be different for providers. This is why we fetch it from the provider itself.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noidc_flow_auth_code <- function(\n  client,\n  provider,\n  scope = \"openid profile email\"\n) {\n  oauth_flow_auth_code(\n    client,\n    provider$authorization_endpoint,\n    scope = scope,\n    redirect_uri = client$redirect_uri\n  )\n}\n```\n:::\n\n\n:::{.callout-note}\nNow that I'm looking at this again, it may be worth storing the the authorization endpoint into the client too...\n:::\n\nWhen we authenticate with OIDC we most also provide the `openid` scope. This indicates to the provider that the OIDC protocol will be used. Additionally, OIDC uses something called json web-tokens (JWT). \n\nJWTs have \"claims\" associated with them. This is basic informations about the user that is authenticated. These get stored alongside the `access_token` as an `id_token`. \n\nThe [standard claim](https://openid.net/specs/openid-connect-basic-1_0.html#StandardClaims) `profile` will give you a lot of basic information about an end-user. It wraps up the name, family_name, given_name, middle_name, nickname, preferred_username, profile, picture, website, gender, birthdate, zoneinfo, and locale claims. \n\nSpecify the claim you want after `openid` in the `scope` argument\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoken <- oidc_flow_auth_code(\n  client, provider,\n  scope = \"openid profile\"\n)\n```\n:::\n\n```\n<httr2_token>\ntoken_type: Bearer\naccess_token: <REDACTED>\nexpires_at: 2024-11-29 11:07:12\nid_token: <REDACTED>\nscope: openid profile\n```\n\nWith this you've now authenticated using OIDC. Though you may want to access the user information in the token. We can do that by decoding the `id_token`.\n\n## Accessing Claims\n\nHere we create a function `parse_id_token()` which takes the contents of `token$id_token` and parses it into something human representable. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoken$id_token\n```\n:::\n\n```\n\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6ImV0WWVUTjhseGJ6VENZblBMNnhxSyJ9.eyJnaXZlbl9uYW1lIjoiSm9zaWFoIiwiZmFtaWx5X25hbWUiOiJQYXJyeSIsIm5pY2tuYW1lIjoiam9zaWFoLnBhcnJ5IiwibmFtZSI6Ikpvc2lhaCBQYXJyeSIsInBpY3R1cmUiOiJodHRwczovL2xoMy5nb29nbGV1c2VyY29udGVudC5...truncate\"\n```\n\nThis is base64 encoded nonsense. Below is an opinionated way to decode this. I utilize the [`{b64}`](https://extendr.github.io/b64/) package for fast decoding. Then use [`{yyjsonr}`](https://coolbutuseless.github.io/package/yyjsonr/index.html) for fast json parsing. \n\n::: {.cell}\n\n```{.r .cell-code}\nparse_id_token <- function(token) {\n  parts <- strsplit(token$id_token, \"\\\\.\")[[1]][1:2]\n  b64::decode(parts, eng = b64::engine(\"url_safe_no_pad\")) |> \n    lapply(rawToChar) |> \n    rlang::set_names(c(\"header\", \"payload\")) |> \n    lapply(yyjsonr::read_json_str)\n}\n```\n:::\n\n```\n$header\n$header$alg\n[1] \"RS256\"\n\n$header$typ\n[1] \"JWT\"\n\n$header$kid\n[1] \"redacted\"\n\n$payload\n$payload$given_name\n[1] \"Josiah\"\n\n$payload$family_name\n[1] \"Parry\"\n\n$payload$nickname\n[1] \"josiah.parry\"\n\n$payload$name\n[1] \"Josiah Parry\"\n\n$payload$picture\n[1] \"redacted\"\n\n$payload$updated_at\n[1] \"2024-11-28T00:46:24.934Z\"\n\n$payload$iss\n[1] \"https://dev-2ts7ytkts28hfj4o.us.auth0.com/\"\n\n$payload$aud\n[1] \"mi3FRXJuJarrM7rFBDr0N270l84ANSXo\"\n\n$payload$iat\n[1] 1732820832\n\n$payload$exp\n[1] 1732856832\n\n$payload$sub\n[1] \"redacted\"\n\n$payload$sid\n[1] \"redacted\"\n```\n\n\n## Authenticating requests with OIDC\n\nHowever, you may want to wrap your requests with your OIDC auth provider.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreq_auth_oidc <- function(req, provider, client, scope = \"openid profile email\") {\n  req |> \n    req_oauth_auth_code(\n      client = client,\n      auth_url = provider$authorization_endpoint,\n      scope = scope,\n      redirect_uri = client$redirect_uri\n    )\n}\n```\n:::\n\n\n\n## Accessing `UserInfo` \n\nEach OIDC provider also has a `UserInfo` endpoint that can be accessed for user-level claims. \n\nWe can wrap this up as well:\n\n\n::: {.cell}\n\n```{.r .cell-code}\noidc_user_info <- function(provider, token) {\n  request(provider[[\"userinfo_endpoint\"]]) |> \n    req_auth_bearer_token(token$access_token) |> \n    req_perform() |> \n    resp_body_json()\n}\n```\n:::\n\n\nNote that this will only give you the user information that is associated with the claims used to authenticate with as well.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}