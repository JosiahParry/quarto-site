{
  "hash": "f272aaef6ef0c96321a2d3d68d18bdba",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Enums in R: towards type safe R\"\ndate: 2023-11-10\nkeep-md: true\ncategories: [r, package-dev, rust]\n---\n\n  \nHadley Wickham has recently dropped a new draft section of his book [Tidy Design Principles](https://design.tidyverse.org/) on [enumerations and their use in R](https://design.tidyverse.org/boolean-strategies.html).\n\n\n\nIn short, **enumerations** enumerate (list out) the possible values that\nsomething might take on. In R we see this most often in function signatures\nwhere an argument takes a scalar value but all possible values are listed out.\n\n::: aside\nI will refer to enumerations as enums from here on.\n:::\n  \n  ## Enums in R \n  \n  A good example is the `cor()` function from the base package `stats`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(cor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, y = NULL, use = \"everything\", method = c(\"pearson\", \n    \"kendall\", \"spearman\")) \nNULL\n```\n\n\n:::\n:::\n\n\nThe possible values for `method` are `\"pearson\"`, `\"kendall\"`, or `\"spearman\"`\nbut all values are listed inside of the function definition. \n\nInside of the function, though, `match.arg(method)` is used to ensure that \nthe provided value to the `method` argument is one of the provided values.\n\nHadley makes the argument that we should prefer an enumeration to a boolean flag\nsuch as `TRUE` or `FALSE`. I agree! \n  \n  ### A real world example\n  \n  A post on mastodon makes a point that the function `sf::st_make_grid()` has an\nargument `square = TRUE` where when set to `FALSE` hexagons are returned. \n\n<iframe src=\"https://mastodon.social/@eliocamp/111387155503851033/embed\" width=\"100%\" height=\"300px\" allowfullscreen=\"allowfullscreen\" sandbox=\"allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-forms\"></iframe>\n  \n  In this case, it's very clear that an enum would be better! For example we can\nimprove the signature like so:\n\n```r\nst_make_grid <- function(x, grid_shape = c(\"square\", \"hexagon\"), ...) {\n  # ensure only one of the provided grid shapes are used\n  match.arg(grid_shape)\n  # ... rest of function \n}\n```\n\n## Enums in Rust\n\nWhen I first started using rust enums made no sense to me. In Rust, enums are a\nfirst class citizen that are treated as their own _thing_. \n\n::: aside\nI'm not really sure what to call _things_ in Rust. Are they all objects?\n  :::\n  \n  We make them by defining the name of the enum and the **_variants_** they may \ntake on. \n\n```rust\nenum GridShape {\n  Square,\n  Hexagon\n}\n```\n\nNow you can use this enum `GridShape` to specify one of two types: `Square`\nor `Hexagon`. Syntactically, this is written `GridShape::Square` and \n`GridShape::Hexagon`. \n\nEnums are very nice because we can match on the variants and do different\nthings based on them. For example we can have a function like so:\n  \n  ```rust\nfn which_shape(x: GridShape) {\n  match x {\n    GridShape::Square => println!(\"We have a square!\"),\n    GridShape::Hexagon => println!(\"Hexagons are the bestagons\")\n  }\n}\n```\n\nIt takes an argument `x` which is a `GridShape` enum. We [match](https://doc.rust-lang.org/book/ch06-02-match.html) on the possible variants\nand then _do something_.\n\n::: aside\nInside of the match statement each of the possible variants of the enum have to\nbe written out. These are called **match arms**. The left side lists the variant\nwhere as the right portion (after `=>`) indicates what will be executed if the \nleft side is matched (essentially if the condition is true).\n:::\n  \n  With this function we can pass in specific variants and get different behavior.\n\n:::{.panel-tabset}\n\n## GridShape::Hexagon\n\n```rust\nwhich_shape(GridShape::Hexagon)\n#> Hexagons are the bestagons\n```\n\n## GridShape::Square\n\n```rust\nwhich_shape(GridShape::Square)\n#> We have a square!\n```\n:::\n  \n  ## Making an S7 enum object in R\n  \n  I think R would benefit from having a _\"real\"_ enum type object. Having a character vector of valid variants and checking against them using \n`match.arg()` or `rlang::arg_match()` is great but I think we can go further.\n\n::: aside\nSince learning Rust, I think having more strictness can make our code much\nbetter and more robust. I think adding enums would be a good step towards that\n:::\n  \n  I've prototyped an `Enum` type in R using the new `S7` object system that\nmight point us towards what an enum object in the future might look like for \nR users. \n\n### Design of an Enum\n\nFor an enum we need to know what the valid **variants** are and what the current\n**value** of the enum is. These would be the two properties.\n\nAn enum S7 object must also make sure that a value of an Enum is one of the\nvalid variants. Using the `GridShape` enum the valid variants would be\n`\"Square\"` and `\"Hexagon\"`. A GridShape enum could not take, for example, \n`\"Circle\"` since it is not a listed variant.\n\n\n### Using an abstract class\n\nTo start, we will create an abstract S7 class called `Enum`. \n\n> \"_an abstract class is a generic class (or type of object) used as a basis for creating specific objects that conform to its protocol, or the set of operations it supports\" \n   — [Source](https://www.techopedia.com/definition/17408/abstract-class)\n\nThe `Enum` class will be used to create other `Enum` objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(S7)\n\n# create a new Enum abstract class\nEnum <- new_class(\n  \"Enum\",\n  properties = list(                               # <1> \n    Value = class_character,                       # <2>\n    Variants = class_character                     # <3>\n  ),\n  validator = function(self) { \n    if (length(self@Value) != 1L) {                # <4> \n      \"enum value's are length 1\"\n    } else if (!(self@Value %in% self@Variants)) { # <5>\n      \"enum value must be one of possible variants\"\n    }\n  }, \n  abstract = TRUE                                 # <6> \n)\n```\n:::\n\n\nIn this code chunk we specify that there are 2 properties: `Value` and `Variant`\neach must be a character type. `Value` will be the value of the enum. It would\nbe the right hand side of `GridShape::Square` in Rust's enum, for example.\n`Variants` is a character vector of all of the possible values it may be\nable to take on. The validator ensures that `Value` must only have 1 value. It\nalso ensures that `Value` is one of the enumerated `Variants`. This `Enum` class\nwill be used to generate other enums and cannot be instantiated by itself.\n\nWe can create a new enum factory function with the arguments:\n\n- `enum_class` the class of the enum we are creating \n- `variants` a character vector of the valid variant values\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a new enum constructor \nnew_enum_class <- function(enum_class, variants) {\n  new_class(\n    enum_class,\n    parent = Enum,\n    properties = list(\n      Value = class_character,\n      Variants = new_property(class_character, default = variants)\n    ),\n    constructor = function(Value) {\n      new_object(S7_object(), Value = Value, Variants = variants)\n    }\n  )\n}\n```\n:::\n\n\n::: aside\nNote that the `constructor` here only takes a `Value` argument. We do this so\nthat users cannot circumvent the pre-defined **variants**. \n:::\n\nWith this we can now create a `GridShape` enum in R! \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGridShape <- new_enum_class(\n  \"GridShape\",\n  c(\"Square\", \"Hexagon\")\n)\n\nGridShape\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<GridShape> class\n@ parent     : <Enum>\n@ constructor: function(Value) {...}\n@ validator  : <NULL>\n@ properties :\n $ Value   : <character>\n $ Variants: <character>\n```\n\n\n:::\n:::\n\n\nThis new object will construct new `GridShape` enums for us. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nGridShape(\"Square\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<GridShape>\n @ Value   : chr \"Square\"\n @ Variants: chr [1:2] \"Square\" \"Hexagon\"\n```\n\n\n:::\n:::\n\n\nWhen we try to create a GridShape that is not one of the valid variants we will\nget an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGridShape(\"Triangle\")\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <GridShape> object is invalid:\n- enum value must be one of possible variants\n```\n\n\n:::\n:::\n\n\n### Making a print method\n\nFor fun, I would like `Enum` objects to print like how I would use them in Rust.\nTo do this we can create a custom print method\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print method for enums\n# since this is an abstract class we get the first class (super)\n# to print\nprint.Enum <- function(x, ...) {\n  cat(class(x)[1], \"::\", x@Value, sep = \"\")\n  invisible(x)\n}\n```\n:::\n\n\nSince `Enum`s will only ever be a sub-class we can confidently grab the first\nelement of the `class(enum_obj)` which is the super-class of the enum. We \npaste that together with the value of the enum. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsquare  <- GridShape(\"Square\")\nsquare\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nGridShape::Square\n```\n\n\n:::\n:::\n\n\n## Drawing even more from Rust \n\nRust enums are even more powerful than what I briefly introduced. Each variant\nof an enum can actually be _typed_!!! Take a look at the example from \n[The Book™](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html).\n\n```rust\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n```\n\nIn this enum there are 4 variants. The first `Quit` doesn't have any associated\ndata with it. But the other three do! The second one `Move` has two fields `x`\nand `y` which contain integer values. `Write` is a tuple with a string in it\nand `ChangeColor` has 3 integer values in its tuple. These can be extracted. \n\nA silly example function that illustrates how each value can be used can be\n\n```rust\nfn which_msg(x: Message) {\n    match x {\n        Message::Quit => println!(\"I'm a quitter\"),\n        Message::Move { x, y } =>  println!(\"Move over {x} and up {y}\"),\n        Message::Write(msg) => println!(\"your message is: {msg}\"),\n        Message::ChangeColor(r, g, b) =>  println!(\"Your RGB ({r}, {g}, {b})\"),\n    }\n}\n```\n\nWhen a variant with data is passed in the values can be used. For example \n\n```rust\nwhich_msg(Message::ChangeColor(0, 155, 200));\n#> Your RGB (0, 155, 200)\n```\n\n### Extending it to R\n\nWhat would this look like if we extended it to an R based enum object? I suspect\nthe `Variants` would be a list of prototypes such as those from [`{vctrs}`](https://vctrs.r-lib.org/). The `Value` would have to be validated\nagainst all of the provided prototypes to ensure that it is one of the provided types. \n\nI'm not sure how I would code this up, but I think that would be a great thing to have. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}