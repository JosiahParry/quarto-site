[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Home Page",
    "section": "",
    "text": "This is a Quarto website. help me\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/index.html",
    "href": "posts/index.html",
    "title": "recent posts",
    "section": "",
    "text": "This shit doesn’t work\n\n\n\n\n\n\n\n\n\n\nComplete spatial randomness\n\n\n\n\n\n\n\n\n\n\n\n\nNov 8, 2022\n\n\nJosiah Parry\n\n\n\n\n\n\n\n\nCreating my quarto blog\n\n\n\n\n\n\n\n\n\n\n\n\nJosiah Parry\n\n\n\n\n\n\n\n\nUntitled\n\n\n\n\n\n\n\n\n\n\n\n\nJosiah Parry\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2022-11-13-making-my-quarto-site.html",
    "href": "posts/2022-11-13-making-my-quarto-site.html",
    "title": "Creating my quarto blog",
    "section": "",
    "text": "The documentation is thin. The Google brain hasn’t yet propagated the best blog posts to the top, yet.\nThe github discussions use the words “just” and “simply” quite a bit as if it’s easy and simple. Like you should have just known to do that. It’s so obvious, clearly!\nhttps://github.com/quarto-dev/quarto-cli/discussions/2949#discussioncomment-3924396"
  },
  {
    "objectID": "posts/a-post.html",
    "href": "posts/a-post.html",
    "title": "Creating my quarto blog",
    "section": "",
    "text": "This really feels a lot more like the general programming exerpeicen I’ve gotten in every language that isn’t R.\nThe documentation is thin. The Google brain hasn’t yet propagated the best blog posts to the top, yet.\nThe github discussions use the words “just” and “simply” quite a bit as if it’s easy and simple. Like you should have just known to do that. It’s so obvious, clearly!\nhttps://github.com/quarto-dev/quarto-cli/discussions/2949#discussioncomment-3924396\nhttps://github.com/quarto-dev/quarto-cli/discussions/2389#discussioncomment-3613262"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Home Page",
    "section": "",
    "text": "To learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "projects",
    "section": "",
    "text": "sfdep\nspdep\ngenius (RIP)\nUrban Informatics Toolkit\nMusic Information Retrieval in R (mirrr)\nR for Progressive Campaigns\n\n\nOpen source contributions"
  },
  {
    "objectID": "posts/csr.html",
    "href": "posts/csr.html",
    "title": "Complete spatial randomness",
    "section": "",
    "text": "< this is a cliche about Tobler’s fist law and things being related in space>. Because of Tobler’s first law, spatial data tend to not follow any specific distribution. So, p-values are sort of…not all that accurate most of the time. P-values in spatial statistics often take a “non-parametric” approach instead of an “analytical” one.\nConsider the t-test. T-tests make the assumption that data are coming from a normal distribution. Then p-values are derived from the cumulative distribution function. The alternative hypothesis, then, is that the true difference in means is not 0.\nIn the spatial case, our alternative hypothesis is generally “the observed statistic different than what we would expect under complete spatial randomness?” But what really does that mean? To know, we have to simulate spatial randomness.\nThere are two approaches to simulating spatial randomness that I’ll go over. One is better than the other. First, I’m going to describe the less good one: bootstrap sampling.\nLoad the super duper cool packages. We create queen contiguity neighbors and row-standardized weights.\nLet’s generate some spatially autocorrelated data. This function is a little slow, but it works."
  },
  {
    "objectID": "posts/csr.html#bootstrap-sampling",
    "href": "posts/csr.html#bootstrap-sampling",
    "title": "Complete spatial randomness",
    "section": "Bootstrap sampling",
    "text": "Bootstrap sampling\nUnder the bootstrap approach we are sampling from existing spatial configurations. In our case there are 144 existing neighborhoods. For our simulations, we will randomly sample from existing neighborhoods and then recalculate our statistic. It helps us by imposing randomness into our statistic. We can then repeat the process nsim times. There is a limitation, however. It is that there are only n - 1 possible neighborhood configurations per location.\nHere we visualize a random point and it’s neighbors.\n\n# for a given location create vector indicating position of\n# neighbors and self\ncolor_block <- function(i, nb) {\n  res <- ifelse(1:length(nb) %in% nb[[i]], \"neighbors\", NA)\n  res[i] <- \"self\"\n  res\n}\n\nPlot a point and its neighbors\n\ngrid |> \n  mutate(block = color_block(sample(1:n(), 1), nb)) |> \n  ggplot(aes(fill = block)) +\n  geom_sf() +\n  labs(title = \"Point and it's neighbors\")\n\n\n\n\nFor bootstrap we grab a point and then the neighbors from another point. This function will randomize a nb list object.\n\ncolor_sample_block <- function(i, nb) {\n  index <- 1:length(nb)\n  not_i <- index[-i]\n  \n  sample_block_focal <- sample(not_i, 1)\n  \n  res <- rep(NA, length(index))\n  \n  res[nb[[sample_block_focal]]] <- \"neighbors\"\n  res[i] <- \"self\"\n  res\n}\n\n# visualize it\ngrid |> \n  mutate(block = color_sample_block(sample(1:n(), 1), nb)) |> \n  ggplot(aes(fill = block)) +\n  geom_sf() +\n  labs(title = \"Point and random point's neighbors\")\n\n\n\n\nOften, we will want to create a reference distribution by creating a large number of simulations—typically 999. As the simulations increase in size, we are limited in the amount of samples we can draw. The number of neighborhoods becomes limiting!\nSay we want to look at income distribution in Boston and the only data we have is at the census tract level. I happen to know that Boston has 207 tracts. If we want to do 999 simulations, after the 206th simulation, we will likely have gone through all over the neighborhood configurations!\nHow can we do this sampling? For each observation, we can sample another location, grab their neighbors, and assign them as the observed location’s neighbors."
  },
  {
    "objectID": "posts/csr.html#bootstrap-simulations",
    "href": "posts/csr.html#bootstrap-simulations",
    "title": "Complete spatial randomness",
    "section": "Bootstrap simulations",
    "text": "Bootstrap simulations\nIn sfdep, we use spdep’s nb object. These are lists that store the row position of the neighbors as integer vectors at each element.\n\nIf you want to learn more about neighbors I gave a talk at NY Hackr MeetUp a few months ago that might help.\n\nHere I define a function that samples from the positions (index), then uses that sample to shuffle up the existing neighborhoods and return a shuffled nb object. Note that I add the nb class back to the list.\n\nbootstrap_nbs <- function(nb) {\n  # create index\n  index <- 1:length(nb)\n  # create a resampled index\n  resampled_index <- sample(index, replace = TRUE)\n  # shuffle the neighbors and reassign class\n  structure(nb[resampled_index], class = c(\"nb\", \"list\"))\n}\n\nLet’s compare some observations\n\nnb[1:3]\n\n[[1]]\n[1]  2 13 14\n\n[[2]]\n[1]  1  3 13 14 15\n\n[[3]]\n[1]  2  4 14 15 16\n\nbootstrap_nbs(nb)[1:3]\n\n[[1]]\n[1]  7  9 19 20 21\n\n[[2]]\n[1]  3  4  5 15 17 27 28 29\n\n[[3]]\n[1]  92  93  94 104 106 116 117 118\n\n\nHere we can see the random pattern. Look’s like there is fair amount of clustering of like values.\n\ngrid |> \n  mutate(x = classInt::classify_intervals(x, 7)) |> \n  ggplot(aes(fill = x)) +\n  geom_sf(color = NA, lwd = 0) +\n  scale_fill_brewer(type = \"div\", palette = 5, direction = -1) +\n  theme_void() \n\n\n\n\nWith the weights and the neighbors we can calculate the global Moran. I’ll refer to this as the “observed.” Store it into an object called obs. We’ll need this to calculate a simulated p-value later.\n\nobs <- global_moran(x, nb, wt)\nobs[[\"I\"]]\n\n[1] 0.346877\n\n\n0.35 is a fair amount of positive spatial autocorrelation indicating that like values tend to cluster. But is this due to random chance, or does it depend on where these locations are? Now that we have the observed value of Moran’s I, we can simulate the value under spatial randomness using the bootstrapped sampling. To do so, we bootstrap sample our neighbors, recalculate the weights and then the global Moran. Now, if you’ve read my vignette on conditional permutation, you know what is coming next. We need to create a reference distribution of the global Moran under spatial randomness. To do that, we apply our boot strap nsim times and recalculate the global Moran with each new neighbor list. I love the function replicate() for these purposes.\n\nnsim = 499 \n\n\nAlso, a thing I’ve started doing is assigning scalars / constants with an equals sign because they typically end up becoming function arguments.\n\n\nreps <- replicate(\n  nsim, {\n    nb_sim <- bootstrap_nbs(nb)\n    wt_sim <- st_weights(nb_sim)\n    global_moran(x, nb_sim, wt_sim)[[\"I\"]]\n  }\n)\n\nhist(reps, xlim = c(min(reps), obs[[\"I\"]]))\nabline(v = obs[[\"I\"]], lty = 2)\n\n\n\n\n\nBootstrap limitations\nThat’s all well and good, but let’s look at this a bit more. Since we’re using the bootstrap approach, we’re limited in the number of unique combinations that are possible. Let’s try something. Let’s calculate the spatial lag nsim times and find the number of unique values that we get.\n\nlags <- replicate(\n  nsim, {\n    # resample the neighbors list\n    nb_sim <- bootstrap_nbs(nb)\n    # recalculate the weights\n    wt_sim <- st_weights(nb_sim)\n    # calculate the lag\n    st_lag(x, nb_sim, wt_sim)\n  }\n)\n\n# cast from matrix to vector\nlags_vec <- as.numeric(lags)\n\n# how many are there?\nlength(lags_vec)\n\n[1] 71856\n\n# how many unique?\nlength(unique(lags_vec))\n\n[1] 144\n\n\nSee this? There are only 144 unique value! That isn’t much! Don’t believe me? Run table(lags_vec). For each location there are only a limited number of combinations that can occur."
  },
  {
    "objectID": "posts/csr.html#conditional-permutation",
    "href": "posts/csr.html#conditional-permutation",
    "title": "Complete spatial randomness",
    "section": "Conditional Permutation",
    "text": "Conditional Permutation\nNow, here is where I want to introduce what I view to be the superior alternative: conditional permutation. Conditional permutation was described by Luc Anselin in his seminal 1995 paper. The idea is that we hold an observation constant, then we randomly assign neighbors. This is like the bootstrap approach but instead of grabbing a random observation’s neighborhood we create a totally new one. We do this be assigning the neighbors randomly from all possible locations.\nLet’s look at how we can program this. For each location we need to sample from an index that excludes the observation’s position. Further we need to ensure that there are the same number of neighbors in each location (cardinality).\n\npermute_nb <- function(nb) {\n  # first get the cardinality\n  cards <- st_cardinalties(nb)\n  # instantiate empty list to fill\n  nb_perm <- vector(mode = \"list\", length = length(nb))\n  \n  # instantiate an index\n  index <- seq_along(nb)\n  \n  # iterate through and full nb_perm\n  for (i in index) {\n    # remove i from the index, then sample and assign\n    nb_perm[[i]] <- sample(index[-i], cards[i])\n  }\n  \n  structure(nb_perm, class = \"nb\")\n}\n\n\nnb[1:3]\n\n[[1]]\n[1]  2 13 14\n\n[[2]]\n[1]  1  3 13 14 15\n\n[[3]]\n[1]  2  4 14 15 16\n\npermute_nb(nb)[1:3]\n\n[[1]]\n[1] 68 71 51\n\n[[2]]\n[1]  27  44  26  35 127\n\n[[3]]\n[1]   6 134  48 136  70\n\n\nNow, let’s repeat the same exercise using conditional permutation.\n\nlags2 <- replicate(\n  nsim, {\n    nb_perm <- permute_nb(nb)\n    st_lag(x, nb_perm, st_weights(nb_perm))\n  }\n)\n\nlags2_vec <- as.numeric(lags2)\n  \nlength(unique(lags2_vec))\n\n[1] 71853\n\n\nThere are farrrrr more unique values. In fact, there is a unique value for each simulation - location pair. If we look at the histograms, the difference is even more stark. The conditional permutation approach actually begins to represent a real distribution.\n\npar(mfrow = c(1, 2))\nhist(lags_vec, breaks = 20) \nhist(lags2_vec, breaks = 20)\n\n\n\n\nSo, this is all for me to say that bootstrapping isn’t it for creating simulated distributions for which to calculate your p-values."
  }
]